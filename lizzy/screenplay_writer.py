"""
Screenplay Writer - Integrates WRITE module with VALENTINE formatter

Takes generated prose from WRITE module and produces professionally
formatted screenplays in multiple formats.
"""

from pathlib import Path
from typing import Optional, Literal
from .screenplay_formatter.parser import ScreenplayParser
from .screenplay_formatter.formatter import TextFormatter, DocxFormatter, PdfFormatter
from .screenplay_formatter.validator import ScreenplayValidator


class ScreenplayWriter:
    """
    Formats generated scenes as professional screenplays.

    Uses VALENTINE's professional formatter to ensure industry-standard
    formatting with dual dialogue, shot headers, page numbering, etc.
    """

    def __init__(self, project_name: str):
        self.project_name = project_name
        self.project_dir = Path(f"projects/{project_name}")
        self.screenplay_dir = self.project_dir / "screenplays"
        self.screenplay_dir.mkdir(exist_ok=True)

        # Initialize formatter components
        self.parser = ScreenplayParser()
        self.validator = ScreenplayValidator()
        self.text_formatter = TextFormatter()
        self.docx_formatter = DocxFormatter()
        self.pdf_formatter = PdfFormatter()

    def format_scene(
        self,
        raw_screenplay: str,
        scene_number: int,
        output_format: Literal["txt", "docx", "pdf"] = "txt",
        validate: bool = True
    ) -> tuple[str, bool, list[str]]:
        """
        Format a raw screenplay scene.

        Args:
            raw_screenplay: Raw screenplay text from LLM
            scene_number: Scene number for naming
            output_format: Output format (txt, docx, or pdf)
            validate: Whether to validate before formatting

        Returns:
            tuple of (output_path, is_valid, validation_errors)
        """
        # Parse the screenplay
        elements = self.parser.parse(raw_screenplay)

        # Validate if requested
        validation_errors = []
        is_valid = True

        if validate:
            validation_report = self.validator.validate(elements)
            is_valid = validation_report.passed
            validation_errors = validation_report.errors

        # Generate output filename
        output_filename = f"scene_{scene_number:02d}.{output_format}"
        output_path = self.screenplay_dir / output_filename

        # Format based on requested format
        if output_format == "txt":
            self.text_formatter.format(elements, str(output_path))
        elif output_format == "docx":
            self.docx_formatter.format(elements, str(output_path))
        elif output_format == "pdf":
            self.pdf_formatter.format(elements, str(output_path))
        else:
            raise ValueError(f"Unknown format: {output_format}")

        return str(output_path), is_valid, validation_errors

    def format_full_screenplay(
        self,
        scenes: list[tuple[int, str]],
        output_format: Literal["txt", "docx", "pdf"] = "docx",
        title: Optional[str] = None
    ) -> str:
        """
        Format multiple scenes into a complete screenplay.

        Args:
            scenes: List of (scene_number, raw_screenplay) tuples
            output_format: Output format
            title: Optional screenplay title for title page

        Returns:
            Path to generated screenplay file
        """
        # Combine all scenes
        combined = []

        # Add title page if provided
        if title:
            combined.append(f"TITLE: {title}")
            combined.append("")
            combined.append(f"by")
            combined.append("")
            combined.append(f"Generated by Lizzy 2.0")
            combined.append("")
            combined.append("===")  # Page break
            combined.append("")

        # Add FADE IN at start
        combined.append("FADE IN:")
        combined.append("")

        # Add all scenes
        for i, (scene_num, screenplay) in enumerate(scenes):
            combined.append(screenplay.strip())

            # Add page break between acts (scenes 6, 24)
            if scene_num in [6, 24]:
                combined.append("")
                combined.append("===")
                combined.append("")

        # Add FADE OUT at end
        combined.append("")
        combined.append("FADE OUT.")

        # Join and format
        full_screenplay = "\n".join(combined)
        elements = self.parser.parse(full_screenplay)

        # Output filename
        output_filename = f"{self.project_name}_screenplay.{output_format}"
        output_path = self.screenplay_dir / output_filename

        # Format
        if output_format == "txt":
            self.text_formatter.format(elements, str(output_path))
        elif output_format == "docx":
            self.docx_formatter.format(elements, str(output_path))
        elif output_format == "pdf":
            self.pdf_formatter.format(elements, str(output_path))

        return str(output_path)

    def get_formatted_preview(self, raw_screenplay: str, max_lines: int = 50) -> str:
        """
        Get a formatted preview of a screenplay (for display).

        Args:
            raw_screenplay: Raw screenplay text
            max_lines: Maximum lines to return

        Returns:
            Formatted screenplay text (truncated)
        """
        elements = self.parser.parse(raw_screenplay)

        # Format as text in memory
        lines = []
        for i, element in enumerate(elements):
            formatted = self.text_formatter._format_element(element)
            if formatted:
                lines.extend(formatted)

            # Add spacing
            if self.text_formatter._needs_spacing_after(element, elements, i):
                lines.append("")

            # Stop if we hit max lines
            if len(lines) >= max_lines:
                lines.append("...")
                lines.append(f"(truncated, showing first {max_lines} lines)")
                break

        return "\n".join(lines)

    def validate_screenplay(self, raw_screenplay: str) -> tuple[bool, list[str]]:
        """
        Validate a screenplay without formatting it.

        Returns:
            tuple of (is_valid, list of error messages)
        """
        elements = self.parser.parse(raw_screenplay)
        return self.validator.validate(elements)
