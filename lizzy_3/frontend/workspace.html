<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lizzy - Workspace</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root { --transition: 0.25s ease; }

    [data-theme="light"] {
      --bg-primary: #fff;
      --bg-secondary: #fafafa;
      --bg-tertiary: #f4f4f5;
      --text-primary: #111;
      --text-secondary: #52525b;
      --text-muted: #71717a;
      --border: #e4e4e7;
      --accent: #3b82f6;
      --accent-bg: #eff6ff;
    }

    [data-theme="dark"] {
      --bg-primary: #18181b;
      --bg-secondary: #111;
      --bg-tertiary: #27272a;
      --text-primary: #fafafa;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;
      --border: #3f3f46;
      --accent: #60a5fa;
      --accent-bg: #1e3a5f;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      transition: background var(--transition), color var(--transition);
    }

    /* Nav */
    nav {
      padding: 0.875rem 1.5rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .nav-left { display: flex; align-items: center; gap: 1.5rem; }
    .logo { font-size: 1rem; font-weight: 600; text-decoration: none; color: var(--text-primary); }
    .project-name { font-size: 0.875rem; color: var(--text-muted); cursor: pointer; }
    .project-name:hover { color: var(--text-primary); }
    .project-name-input {
      font-size: 0.875rem;
      color: var(--text-primary);
      background: var(--bg-tertiary);
      border: 1px solid var(--accent);
      border-radius: 0.25rem;
      padding: 0.25rem 0.5rem;
      outline: none;
      width: 200px;
    }

    /* Project Progress Indicator */
    .progress-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 1rem;
      padding-left: 1rem;
      border-left: 1px solid var(--border);
    }

    .progress-dots {
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }

    .progress-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border);
      transition: all 0.3s;
      cursor: help;
    }

    .progress-dot.filled {
      background: var(--accent);
    }

    .progress-dot.partial {
      background: linear-gradient(90deg, var(--accent) 50%, var(--border) 50%);
    }

    .progress-label {
      font-size: 0.6875rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    .progress-label.clickable {
      cursor: pointer;
    }

    .progress-label.clickable:hover {
      color: var(--text-primary);
    }

    .nav-right { display: flex; align-items: center; gap: 1rem; }
    .save-btn {
      font-size: 0.75rem;
      color: var(--text-primary);
      padding: 0.375rem 0.75rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .save-btn:hover { background: var(--accent); color: white; border-color: var(--accent); }
    .nav-link { color: var(--text-secondary); text-decoration: none; font-size: 0.8125rem; font-weight: 500; }
    .nav-link:hover { color: var(--text-primary); }

    /* Main workspace */
    .workspace {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Left Panel - Outline */
    .panel-left {
      width: 50%;
      min-width: 300px;
      max-width: 70%;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border);
      overflow: hidden;
    }

    /* Resizer */
    .resizer {
      width: 6px;
      background: var(--border);
      cursor: col-resize;
      flex-shrink: 0;
      transition: background 0.2s;
    }

    .resizer:hover, .resizer.dragging {
      background: var(--accent);
    }

    /* Right Panel - Chat */
    .panel-right {
      flex: 1;
      min-width: 300px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Outline Panel Styles */
    .outline-tabs {
      display: flex;
      gap: 0.25rem;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      flex-shrink: 0;
    }

    .outline-tab {
      padding: 0.375rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 0.375rem;
      transition: all 0.2s;
    }

    .outline-tab:hover { color: var(--text-primary); background: var(--bg-tertiary); }
    .outline-tab.active { color: var(--text-primary); background: var(--bg-tertiary); }

    .outline-content {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .tab-panel { display: none; }
    .tab-panel.active { display: block; }

    /* Form styles */
    .form-group { margin-bottom: 1rem; }
    .form-group:last-child { margin-bottom: 0; }

    .form-group label {
      display: block;
      font-size: 0.6875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 0.375rem;
    }

    .form-group input,
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.8125rem;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .form-group textarea { resize: vertical; min-height: 80px; line-height: 1.5; }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    /* List items */
    .list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .list-header h3 {
      font-size: 0.6875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .btn-sm {
      padding: 0.25rem 0.5rem;
      font-size: 0.6875rem;
      border: 1px solid var(--border);
      border-radius: 0.25rem;
      background: var(--bg-primary);
      color: var(--text-primary);
      cursor: pointer;
    }

    .btn-sm:hover { border-color: var(--text-muted); }

    .list-item {
      padding: 0.625rem 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .list-item:hover { border-color: var(--text-muted); }

    .list-item-name { font-size: 0.8125rem; font-weight: 500; }
    .list-item-meta { font-size: 0.6875rem; color: var(--text-muted); margin-top: 0.125rem; }

    .list-item-content { flex: 1; min-width: 0; }

    .scene-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .scene-drag-handle {
      cursor: grab;
      color: var(--text-muted);
      opacity: 0.4;
      font-size: 0.75rem;
      padding: 0.25rem;
      user-select: none;
    }

    .scene-drag-handle:hover { opacity: 1; }
    .scene-item.dragging { opacity: 0.5; background: var(--bg-tertiary); }
    .scene-item.drag-over { border-color: var(--accent); border-style: dashed; }

    .scene-delete {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
      opacity: 0;
      transition: opacity 0.2s, color 0.2s;
    }

    .list-item:hover .scene-delete { opacity: 0.6; }
    .scene-delete:hover { opacity: 1 !important; color: #dc2626; }

    .empty-list {
      text-align: center;
      padding: 2rem;
      color: var(--text-muted);
      font-size: 0.8125rem;
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal.hidden { display: none; }
    .modal-content {
      background: var(--bg-primary);
      border-radius: 0.75rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 400px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-content h2 {
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }
    .modal-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
      margin-top: 1.25rem;
    }
    .btn { padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.8125rem; font-weight: 500; cursor: pointer; }
    .btn-primary { background: var(--text-primary); color: var(--bg-primary); border: none; }
    .btn-secondary { background: transparent; color: var(--text-secondary); border: 1px solid var(--border); }
    .btn-danger { background: #dc2626; color: white; border: none; }

    /* Chat Panel Styles */
    .chat-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      flex-shrink: 0;
    }

    .chat-header-top {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .chat-header-top select {
      flex: 1;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .convo-actions {
      display: flex;
      gap: 0.25rem;
    }

    .convo-action-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem 0.375rem;
      font-size: 0.6875rem;
      border-radius: 0.25rem;
      transition: all 0.2s;
    }

    .convo-action-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .convo-action-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .convo-action-btn.delete:hover {
      color: #dc2626;
    }

    .chat-header h3 {
      font-size: 0.8125rem;
      font-weight: 600;
    }

    .bucket-toggles {
      display: flex;
      gap: 0.375rem;
    }

    .bucket-chip {
      padding: 0.25rem 0.5rem;
      font-size: 0.625rem;
      font-weight: 500;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .bucket-chip:hover { border-color: var(--text-muted); }
    .bucket-chip.active { border-color: var(--accent); background: var(--accent-bg); color: var(--accent); }
    .bucket-chip.disabled { opacity: 0.4; cursor: not-allowed; }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .message {
      max-width: 85%;
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      font-size: 0.8125rem;
      line-height: 1.5;
    }

    .message.user {
      align-self: flex-end;
      background: var(--accent);
      color: white;
      border-bottom-right-radius: 0.25rem;
    }

    .message.assistant {
      align-self: flex-start;
      background: var(--bg-tertiary);
      border-bottom-left-radius: 0.25rem;
    }

    .message.system {
      align-self: center;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      font-size: 0.6875rem;
      padding: 0.375rem 0.75rem;
    }

    .chat-empty {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      text-align: center;
      padding: 2rem;
    }

    .chat-empty h3 { font-size: 0.9375rem; margin-bottom: 0.5rem; color: var(--text-secondary); }
    .chat-empty p { font-size: 0.75rem; max-width: 280px; }

    .chat-input {
      padding: 0.75rem 1rem;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 0.5rem;
      flex-shrink: 0;
    }

    .chat-input input {
      flex: 1;
      padding: 0.625rem 0.875rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      font-size: 0.8125rem;
    }

    .chat-input input:focus { outline: none; border-color: var(--accent); }

    .chat-input button {
      padding: 0.625rem 1rem;
      border: none;
      border-radius: 0.5rem;
      background: var(--accent);
      color: white;
      font-size: 0.8125rem;
      font-weight: 500;
      cursor: pointer;
    }

    .chat-input button:hover { opacity: 0.9; }
    .chat-input button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Loading dots */
    .loading-dots { display: inline-flex; gap: 0.2rem; }
    .loading-dots span { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); animation: bounce 1.4s infinite ease-in-out both; }
    .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
    .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }

    /* Canvas Styles */
    .canvas-nav {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid var(--border);
    }

    .canvas-nav-btn {
      padding: 0.375rem 0.625rem;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.25rem;
      background: var(--bg-primary);
      color: var(--text-primary);
      cursor: pointer;
    }

    .canvas-nav-btn:hover:not(:disabled) { border-color: var(--text-muted); }
    .canvas-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    #sceneSelector {
      flex: 1;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.25rem;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .screenplay-canvas {
      flex: 1;
      overflow-y: auto;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      min-height: 400px;
    }

    .canvas-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      min-height: 300px;
      color: var(--text-muted);
      text-align: center;
      padding: 2rem;
    }

    .canvas-empty p { margin: 0.25rem 0; }
    .canvas-hint { font-size: 0.75rem; }

    .screenplay-content {
      padding: 1.5rem;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      line-height: 1.5;
    }

    /* Scene Heading */
    .scene-heading {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin-bottom: 1rem;
      text-transform: uppercase;
    }

    .screenplay-select {
      padding: 0.25rem 0.375rem;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      font-weight: bold;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
      cursor: pointer;
    }

    .screenplay-select:hover { border-color: var(--border); }
    .screenplay-select:focus { outline: none; border-color: var(--accent); }

    .screenplay-input-location {
      flex: 1;
      padding: 0.25rem 0.375rem;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
    }

    .screenplay-input-location:hover { border-color: var(--border); }
    .screenplay-input-location:focus { outline: none; border-color: var(--accent); }
    .screenplay-input-location::placeholder { color: var(--text-muted); }

    .screenplay-dash { color: var(--text-muted); }

    /* Screenplay Body */
    .screenplay-body {
      min-height: 200px;
    }

    .screenplay-element {
      margin-bottom: 0.75rem;
      position: relative;
    }

    .screenplay-element:hover .element-delete {
      opacity: 1;
    }

    .element-delete {
      position: absolute;
      right: -24px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      border: none;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      border-radius: 50%;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .element-delete:hover { background: #ef4444; color: white; }

    /* Action */
    .element-action textarea {
      width: 100%;
      padding: 0.375rem;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      line-height: 1.5;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
      resize: vertical;
      min-height: 40px;
    }

    .element-action textarea:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--bg-primary);
    }

    /* Character Name */
    .element-character input {
      display: block;
      margin: 0 auto;
      width: 50%;
      text-align: center;
      text-transform: uppercase;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      font-weight: bold;
      padding: 0.25rem;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
    }

    .element-character input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--bg-primary);
    }

    /* Dialogue */
    .element-dialogue textarea {
      display: block;
      margin: 0 auto;
      width: 60%;
      padding: 0.375rem;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      line-height: 1.5;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
      resize: vertical;
      min-height: 40px;
    }

    .element-dialogue textarea:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--bg-primary);
    }

    /* Parenthetical */
    .element-parenthetical input {
      display: block;
      margin: 0 auto;
      width: 40%;
      text-align: center;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      font-style: italic;
      padding: 0.25rem;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
    }

    .element-parenthetical input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--bg-primary);
    }

    /* Transition */
    .element-transition input {
      display: block;
      margin-left: auto;
      width: 30%;
      text-align: right;
      text-transform: uppercase;
      font-family: "Courier New", Courier, monospace;
      font-size: 12px;
      padding: 0.25rem;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-primary);
    }

    .element-transition input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--bg-primary);
    }

    /* Add Element Bar */
    .add-element-bar {
      display: flex;
      gap: 0.375rem;
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px dashed var(--border);
    }

    .add-element-btn {
      padding: 0.25rem 0.5rem;
      font-size: 0.625rem;
      font-weight: 500;
      border: 1px solid var(--border);
      border-radius: 0.25rem;
      background: var(--bg-primary);
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-element-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Canvas Footer */
    .canvas-footer {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border);
    }

    .canvas-status {
      font-size: 0.6875rem;
      color: var(--text-muted);
    }

    /* Memory tab styles */
    .memory-stats {
      padding: 0.75rem;
      background: var(--bg-secondary);
      border-radius: 6px;
      margin-bottom: 1rem;
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .memory-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      max-height: calc(100vh - 300px);
      overflow-y: auto;
    }
    .memory-item {
      padding: 0.75rem;
      background: var(--bg-secondary);
      border-radius: 6px;
      border-left: 3px solid var(--accent);
    }
    .memory-item .memory-text {
      font-size: 0.8125rem;
      margin-bottom: 0.25rem;
    }
    .memory-item .memory-meta {
      font-size: 0.6875rem;
      color: var(--text-muted);
    }
    .memory-item .memory-entity {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 0.125rem 0.375rem;
      border-radius: 3px;
      font-size: 0.625rem;
      margin-right: 0.25rem;
    }
    .memory-empty {
      text-align: center;
      color: var(--text-muted);
      padding: 2rem;
    }

    /* Phase influences defaults but doesn't hide anything */
    /* All tabs always accessible */

    /* Intake panel styles - shown as a tab option */
    #panel-intake {
      display: none;
    }

    #panel-intake.active {
      display: block;
    }

    .intake-header {
      text-align: center;
      padding: 2rem 1rem;
      border-bottom: 1px solid var(--border);
      margin-bottom: 1.5rem;
    }

    .intake-header h2 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .intake-header p {
      font-size: 0.8125rem;
      color: var(--text-secondary);
    }

    .intake-field {
      margin-bottom: 1.25rem;
    }

    .intake-field label {
      display: block;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 0.375rem;
    }

    .intake-field textarea {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 0.875rem;
      font-family: inherit;
      resize: vertical;
      min-height: 60px;
    }

    .intake-field textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    .intake-progress {
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border);
      text-align: center;
    }

    .next-phase-btn {
      padding: 0.75rem 1.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .next-phase-btn:hover { opacity: 0.9; }
    .next-phase-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .phase-hint {
      font-size: 0.6875rem;
      color: var(--text-muted);
      margin-top: 0.5rem;
    }

    /* Act structure in Scenes tab */
    .act-section {
      margin-bottom: 1rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      overflow: hidden;
    }

    .act-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      background: var(--bg-tertiary);
      cursor: pointer;
      user-select: none;
    }

    .act-header:hover {
      background: var(--bg-secondary);
    }

    .act-title-area {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .act-toggle {
      font-size: 0.75rem;
      color: var(--text-muted);
      transition: transform 0.2s;
    }

    .act-section.collapsed .act-toggle {
      transform: rotate(-90deg);
    }

    .act-title {
      font-size: 0.875rem;
      font-weight: 600;
    }

    .act-title-input {
      font-size: 0.875rem;
      font-weight: 600;
      background: var(--bg-primary);
      border: 1px solid var(--accent);
      border-radius: 0.25rem;
      padding: 0.125rem 0.375rem;
      outline: none;
    }

    .act-scene-count {
      font-size: 0.6875rem;
      color: var(--text-muted);
    }

    .act-actions {
      display: flex;
      gap: 0.25rem;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .act-header:hover .act-actions {
      opacity: 1;
    }

    .act-action-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem;
      font-size: 0.75rem;
    }

    .act-action-btn:hover {
      color: var(--text-primary);
    }

    .act-action-btn.delete:hover {
      color: #dc2626;
    }

    .act-scenes {
      padding: 0.5rem;
      min-height: 40px;
    }

    .act-section.collapsed .act-scenes {
      display: none;
    }

    .act-empty {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      border: 1px dashed var(--border);
      border-radius: 0.375rem;
      margin: 0.25rem;
      color: var(--text-muted);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .act-empty:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(139, 92, 246, 0.05);
    }

    .unassigned-section {
      margin-top: 1.5rem;
    }

    .unassigned-header {
      font-size: 0.6875rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
      padding-left: 0.25rem;
    }

    .add-act-btn {
      width: 100%;
      padding: 0.75rem;
      margin-top: 1rem;
      background: none;
      border: 1px dashed var(--border);
      border-radius: 0.5rem;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 0.8125rem;
      transition: all 0.2s;
    }

    .add-act-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .scenes-hint {
      text-align: center;
      padding: 2rem 1rem;
      color: var(--text-muted);
      font-size: 0.8125rem;
    }

    .scenes-hint h4 {
      font-size: 0.9375rem;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .scenes-hint p {
      margin-bottom: 1rem;
    }

    .scenes-hint-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
    }

    .scenes-hint-btn {
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      font-size: 0.8125rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .scenes-hint-btn.primary {
      background: var(--accent);
      color: white;
      border: none;
    }

    .scenes-hint-btn.primary:hover {
      opacity: 0.9;
    }

    .scenes-hint-btn.secondary {
      background: none;
      border: 1px solid var(--border);
      color: var(--text-secondary);
    }

    .scenes-hint-btn.secondary:hover {
      border-color: var(--text-muted);
    }

  </style>
</head>
<body>
  <nav>
    <div class="nav-left">
      <a href="home.html" class="logo">lizzy</a>
      <span class="project-name" id="projectName" onclick="editProjectName()" title="Click to edit">Loading...</span>
      <input type="text" class="project-name-input" id="projectNameInput" onblur="saveProjectName()" onkeydown="if(event.key==='Enter')saveProjectName()" style="display:none;">
      <div class="progress-indicator">
        <div class="progress-dots">
          <span class="progress-dot" id="dotIdea" title="Idea (title/logline)"></span>
          <span class="progress-dot" id="dotCharacters" title="Characters"></span>
          <span class="progress-dot" id="dotStructure" title="Structure (scenes)"></span>
          <span class="progress-dot" id="dotDrafts" title="Drafts"></span>
        </div>
        <span class="progress-label" id="progressLabel">Getting started</span>
      </div>
    </div>
    <div class="nav-right">
      <button class="save-btn" id="saveStatus" onclick="manualSave()">Save</button>
      <a href="projects.html" class="nav-link">Projects</a>
      <a href="buckets.html" class="nav-link">Buckets</a>
      <a href="settings.html" class="nav-link">Settings</a>
    </div>
  </nav>

  <div class="workspace">
    <!-- Left Panel: Outline -->
    <div class="panel-left" id="panelLeft">
      <div class="outline-tabs">
        <div class="outline-tab" data-tab="idea">Idea</div>
        <div class="outline-tab active" data-tab="project">Project</div>
        <div class="outline-tab" data-tab="notes">Notes</div>
        <div class="outline-tab" data-tab="characters">Characters</div>
        <div class="outline-tab" data-tab="scenes">Scenes</div>
        <div class="outline-tab" data-tab="canvas">Canvas</div>
        <div class="outline-tab" data-tab="memory">Memory</div>
      </div>

      <div class="outline-content">
        <!-- Project Tab -->
        <div class="tab-panel active" id="panel-project">
          <div class="form-group">
            <label>Title</label>
            <input type="text" id="title" placeholder="Your screenplay title">
          </div>
          <div class="form-group">
            <label>Logline</label>
            <textarea id="logline" placeholder="A one-sentence summary..."></textarea>
          </div>
          <div class="form-group">
            <label>Description</label>
            <textarea id="description" placeholder="Longer synopsis..."></textarea>
          </div>
        </div>

        <!-- Notes Tab -->
        <div class="tab-panel" id="panel-notes">
          <div class="form-group">
            <label>Theme</label>
            <textarea id="theme" placeholder="What is this story really about?"></textarea>
          </div>
          <div class="form-group">
            <label>Tone</label>
            <input type="text" id="tone" placeholder="e.g., witty, grounded, warm">
          </div>
          <div class="form-group">
            <label>Comps</label>
            <input type="text" id="comps" placeholder="e.g., When Harry Met Sally meets The Proposal">
          </div>
          <div class="form-group">
            <label>Braindump</label>
            <textarea id="braindump" placeholder="Random ideas, fragments, notes..."></textarea>
          </div>
        </div>

        <!-- Characters Tab -->
        <div class="tab-panel" id="panel-characters">
          <div class="list-header">
            <h3>Characters</h3>
            <button class="btn-sm" onclick="addCharacter()">+ Add</button>
          </div>
          <div id="charactersList"></div>
        </div>

        <!-- Scenes Tab -->
        <div class="tab-panel" id="panel-scenes">
          <div class="list-header">
            <h3>Scenes</h3>
            <button class="btn-sm" onclick="addScene()">+ Scene</button>
          </div>
          <div id="actsList"></div>
          <button class="add-act-btn" onclick="addAct()">+ Add Act</button>
        </div>

        <!-- Canvas Tab -->
        <div class="tab-panel" id="panel-canvas">
          <div class="canvas-nav">
            <button class="canvas-nav-btn" onclick="prevScene()" id="prevSceneBtn" disabled>&larr; Prev</button>
            <select id="sceneSelector" onchange="loadSceneToCanvas()">
              <option value="">Select a scene...</option>
            </select>
            <button class="canvas-nav-btn" onclick="nextScene()" id="nextSceneBtn">&rarr; Next</button>
          </div>

          <div class="screenplay-canvas" id="screenplayCanvas">
            <div class="canvas-empty" id="canvasEmpty">
              <p>Select a scene to start writing</p>
              <p class="canvas-hint">Create scenes in the Scenes tab first, then write them here.</p>
            </div>

            <div class="screenplay-content" id="screenplayContent" style="display: none;">
              <!-- Scene Heading -->
              <div class="screenplay-element scene-heading">
                <select id="sceneIntExt" class="screenplay-select">
                  <option value="INT.">INT.</option>
                  <option value="EXT.">EXT.</option>
                  <option value="INT./EXT.">INT./EXT.</option>
                </select>
                <input type="text" id="sceneLocation" class="screenplay-input-location" placeholder="LOCATION">
                <span class="screenplay-dash">-</span>
                <select id="sceneTime" class="screenplay-select">
                  <option value="DAY">DAY</option>
                  <option value="NIGHT">NIGHT</option>
                  <option value="MORNING">MORNING</option>
                  <option value="EVENING">EVENING</option>
                  <option value="LATER">LATER</option>
                  <option value="CONTINUOUS">CONTINUOUS</option>
                </select>
              </div>

              <!-- Screenplay Body -->
              <div class="screenplay-body" id="screenplayBody">
                <!-- Elements are added dynamically -->
              </div>

              <!-- Add Element Buttons -->
              <div class="add-element-bar">
                <button class="add-element-btn" onclick="addElement('action')">+ Action</button>
                <button class="add-element-btn" onclick="addElement('character')">+ Character</button>
                <button class="add-element-btn" onclick="addElement('dialogue')">+ Dialogue</button>
                <button class="add-element-btn" onclick="addElement('parenthetical')">+ Parenthetical</button>
                <button class="add-element-btn" onclick="addElement('transition')">+ Transition</button>
              </div>
            </div>
          </div>

          <div class="canvas-footer">
            <button class="btn-sm" onclick="saveCanvas()" id="saveCanvasBtn">Save Scene</button>
            <span class="canvas-status" id="canvasStatus"></span>
          </div>
        </div>

        <!-- Memory Tab - View Hindsight memories -->
        <div class="tab-panel" id="panel-memory">
          <div class="list-header">
            <h3>Syd's Memory</h3>
            <button class="btn-sm" onclick="loadMemories()">Refresh</button>
          </div>
          <div class="memory-stats" id="memoryStats"></div>
          <div class="memory-list" id="memoryList">
            <p class="memory-empty">Loading memories...</p>
          </div>
        </div>

        <!-- Idea Tab - Quick capture for the spark -->
        <div class="tab-panel" id="panel-idea">
          <div class="intake-header">
            <h2>Capture the spark</h2>
            <p>Jot down whatever's in your head. Or just talk to Syd.</p>
          </div>

          <div class="intake-field">
            <label>The Idea</label>
            <textarea id="ideaSpark" placeholder="What's the core idea? A situation, a character, a 'what if'..."></textarea>
          </div>

          <div class="intake-field">
            <label>The Feeling</label>
            <textarea id="ideaFeeling" placeholder="What emotion should it evoke?"></textarea>
          </div>

          <div class="intake-field">
            <label>Inspirations</label>
            <textarea id="ideaInspirations" placeholder="Movies, books, real life moments..."></textarea>
          </div>

          <div class="intake-progress">
            <button class="next-phase-btn" onclick="saveIdeaToNotes()">Save to Notes</button>
            <p class="phase-hint">These notes flow into your braindump</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Resizer -->
    <div class="resizer" id="resizer"></div>

    <!-- Right Panel: Chat -->
    <div class="panel-right">
      <div class="chat-header">
        <div class="chat-header-top">
          <select id="conversationSelect" onchange="loadConversation()">
            <option value="">New Chat</option>
          </select>
          <div class="convo-actions">
            <button class="convo-action-btn" onclick="renameConversation()" id="renameConvoBtn" disabled title="Rename">✎</button>
            <button class="convo-action-btn delete" onclick="deleteConversation()" id="deleteConvoBtn" disabled title="Delete">✕</button>
            <button class="convo-action-btn" onclick="newConversation()" title="New Chat">+</button>
          </div>
        </div>
        <div class="bucket-toggles">
          <span class="bucket-chip" data-bucket="books-final" onclick="toggleBucket('books-final')">Books</span>
          <span class="bucket-chip" data-bucket="plays-final" onclick="toggleBucket('plays-final')">Plays</span>
          <span class="bucket-chip" data-bucket="scripts-final" onclick="toggleBucket('scripts-final')">Scripts</span>
        </div>
      </div>

      <div class="chat-messages" id="messages">
        <div class="chat-empty" id="chatEmpty">
          <h3>Ask Syd anything</h3>
          <p>Get help with your screenplay. Toggle knowledge sources above for domain expertise.</p>
        </div>
      </div>

      <div class="chat-input">
        <input type="text" id="chatInput" placeholder="Ask Syd..." autofocus>
        <button id="sendBtn" onclick="sendMessage()">Send</button>
      </div>
    </div>
  </div>

  <!-- Character Modal -->
  <div class="modal hidden" id="characterModal">
    <div class="modal-content">
      <h2 id="characterModalTitle">Add Character</h2>
      <input type="hidden" id="characterId">
      <div class="form-group">
        <label>Name</label>
        <input type="text" id="charName" placeholder="Character name">
      </div>
      <div class="form-group">
        <label>Role</label>
        <input type="text" id="charRole" placeholder="e.g., Protagonist, Love Interest">
      </div>
      <div class="form-group">
        <label>Description</label>
        <textarea id="charDescription" placeholder="Brief character description"></textarea>
      </div>
      <div class="form-group">
        <label>Arc</label>
        <textarea id="charArc" placeholder="Character's journey/transformation"></textarea>
      </div>
      <div class="form-group">
        <label>Flaw</label>
        <input type="text" id="charFlaw" placeholder="Main character flaw">
      </div>
      <div class="modal-actions">
        <button class="btn btn-danger" id="deleteCharBtn" onclick="deleteCharacter()" style="margin-right: auto; display: none;">Delete</button>
        <button class="btn btn-secondary" onclick="hideCharacterModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveCharacter()">Save</button>
      </div>
    </div>
  </div>

  <script>
    // Theme
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);

    const API_BASE = 'http://localhost:8000';

    // State
    let activeBuckets = [];
    let availableBuckets = {};
    let chatHistory = [];
    let saveTimeout = null;
    let currentConversationId = null;
    let conversations = [];
    // Project state for progress tracking
    let projectState = {
      hasTitle: false,
      hasLogline: false,
      characterCount: 0,
      sceneCount: 0,
      scenesWithContent: 0
    };

    // ===================
    // PROJECT PROGRESS
    // ===================
    function updateProjectProgress() {
      // Update dots based on project state
      const dotIdea = document.getElementById('dotIdea');
      const dotCharacters = document.getElementById('dotCharacters');
      const dotStructure = document.getElementById('dotStructure');
      const dotDrafts = document.getElementById('dotDrafts');
      const label = document.getElementById('progressLabel');

      // Idea: title or logline
      if (projectState.hasTitle && projectState.hasLogline) {
        dotIdea.className = 'progress-dot filled';
      } else if (projectState.hasTitle || projectState.hasLogline) {
        dotIdea.className = 'progress-dot partial';
      } else {
        dotIdea.className = 'progress-dot';
      }

      // Characters
      if (projectState.characterCount >= 3) {
        dotCharacters.className = 'progress-dot filled';
      } else if (projectState.characterCount > 0) {
        dotCharacters.className = 'progress-dot partial';
      } else {
        dotCharacters.className = 'progress-dot';
      }

      // Structure (scenes)
      if (projectState.sceneCount >= 10) {
        dotStructure.className = 'progress-dot filled';
      } else if (projectState.sceneCount > 0) {
        dotStructure.className = 'progress-dot partial';
      } else {
        dotStructure.className = 'progress-dot';
      }

      // Drafts (scenes with canvas content)
      if (projectState.scenesWithContent >= 10) {
        dotDrafts.className = 'progress-dot filled';
      } else if (projectState.scenesWithContent > 0) {
        dotDrafts.className = 'progress-dot partial';
      } else {
        dotDrafts.className = 'progress-dot';
      }

      // Update label based on state
      if (projectState.scenesWithContent >= 10) {
        label.textContent = 'Writing';
      } else if (projectState.sceneCount >= 10) {
        label.textContent = 'Structured';
      } else if (projectState.characterCount >= 2) {
        label.textContent = 'Developing';
      } else if (projectState.hasTitle || projectState.hasLogline) {
        label.textContent = 'Has an idea';
      } else {
        label.textContent = 'Getting started';
      }
    }

    async function saveIdeaToNotes() {
      const spark = document.getElementById('ideaSpark')?.value || '';
      const feeling = document.getElementById('ideaFeeling')?.value || '';
      const inspirations = document.getElementById('ideaInspirations')?.value || '';

      // Get existing braindump and append
      let braindump = document.getElementById('braindump')?.value || '';

      let newContent = '';
      if (spark) newContent += `**The Spark:** ${spark}\n\n`;
      if (feeling) newContent += `**The Feeling:** ${feeling}\n\n`;
      if (inspirations) newContent += `**Inspirations:** ${inspirations}\n\n`;

      if (newContent) {
        braindump = newContent + (braindump ? '---\n\n' + braindump : '');

        try {
          await fetch(`${API_BASE}/api/outline/notes`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ braindump })
          });

          // Update the braindump textarea
          document.getElementById('braindump').value = braindump;

          // Clear the idea fields
          document.getElementById('ideaSpark').value = '';
          document.getElementById('ideaFeeling').value = '';
          document.getElementById('ideaInspirations').value = '';

          // Switch to notes tab to show them
          switchToTab('notes');

          addSystemMessage('Ideas saved to notes');
        } catch (e) {
          console.error('Failed to save idea:', e);
        }
      }
    }

    function switchToTab(tabName) {
      document.querySelectorAll('.outline-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      const tab = document.querySelector(`[data-tab="${tabName}"]`);
      if (tab) {
        tab.classList.add('active');
        document.getElementById('panel-' + tabName).classList.add('active');
      }
    }

    // ===================
    // RESIZER
    // ===================
    const resizer = document.getElementById('resizer');
    const panelLeft = document.getElementById('panelLeft');
    let isResizing = false;

    resizer.addEventListener('mousedown', (e) => {
      isResizing = true;
      resizer.classList.add('dragging');
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      const containerWidth = document.querySelector('.workspace').offsetWidth;
      const newWidth = (e.clientX / containerWidth) * 100;
      if (newWidth >= 20 && newWidth <= 70) {
        panelLeft.style.width = newWidth + '%';
      }
    });

    document.addEventListener('mouseup', () => {
      isResizing = false;
      resizer.classList.remove('dragging');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    });

    // ===================
    // OUTLINE TABS
    // ===================
    document.querySelectorAll('.outline-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.outline-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
        // Auto-load memories when Memory tab is clicked
        if (tab.dataset.tab === 'memory') {
          loadMemories();
        }
      });
    });

    // ===================
    // DATA LOADING
    // ===================

    async function loadMemories() {
      const list = document.getElementById('memoryList');
      const stats = document.getElementById('memoryStats');

      try {
        // Get project to find bank ID
        const projRes = await fetch(`${API_BASE}/api/outline/project`);
        const project = await projRes.json();
        const bankId = project.memory_bank_id;

        if (!bankId) {
          list.innerHTML = '<p class="memory-empty">No memory bank linked to this project</p>';
          stats.innerHTML = '';
          return;
        }

        // Fetch memories via proxy
        const memRes = await fetch(`${API_BASE}/api/memory/banks/${bankId}/memories`);
        const data = await memRes.json();
        const memories = data.items || [];

        // Stats
        const entities = [...new Set(memories.map(m => m.entities).filter(Boolean))];
        stats.innerHTML = `<strong>${memories.length}</strong> memories about <strong>${entities.length}</strong> entities: ${entities.slice(0, 5).join(', ')}${entities.length > 5 ? '...' : ''}`;

        // Render memories
        if (memories.length === 0) {
          list.innerHTML = '<p class="memory-empty">No memories yet. Chat with Syd to build project memory.</p>';
          return;
        }

        list.innerHTML = memories.map(m => `
          <div class="memory-item">
            <div class="memory-text">${m.text}</div>
            <div class="memory-meta">
              ${m.entities ? `<span class="memory-entity">${m.entities}</span>` : ''}
              ${m.fact_type || 'observation'} · ${new Date(m.date).toLocaleDateString()}
            </div>
          </div>
        `).join('');
      } catch (e) {
        console.error('Failed to load memories:', e);
        list.innerHTML = '<p class="memory-empty">Could not load memories. Is Hindsight running?</p>';
        stats.innerHTML = '';
      }
    }

    async function loadOutline() {
      try {
        const res = await fetch(`${API_BASE}/api/outline`);
        if (!res.ok) throw new Error('Failed to load');
        const data = await res.json();

        // Project
        if (data.project) {
          document.getElementById('title').value = data.project.title || '';
          document.getElementById('logline').value = data.project.logline || '';
          document.getElementById('description').value = data.project.description || '';
          document.getElementById('projectName').textContent = data.project.title || 'Untitled';

          // Update project state
          projectState.hasTitle = !!(data.project.title && data.project.title.trim());
          projectState.hasLogline = !!(data.project.logline && data.project.logline.trim());
        }

        // Characters - count named ones
        const characters = data.characters || [];
        projectState.characterCount = characters.filter(c => c.name && c.name.trim()).length;

        // Scenes
        const scenes = data.scenes || [];
        projectState.sceneCount = scenes.length;
        projectState.scenesWithContent = scenes.filter(s => s.canvas_content && s.canvas_content.trim()).length;

        // Update progress indicator
        updateProjectProgress();

        // Notes
        if (data.notes) {
          document.getElementById('theme').value = data.notes.theme || '';
          document.getElementById('tone').value = data.notes.tone || '';
          document.getElementById('comps').value = data.notes.comps || '';
          document.getElementById('braindump').value = data.notes.braindump || '';
        }

        // Characters
        renderCharacters(data.characters || []);

        // Acts and Scenes
        renderActsAndScenes(data.acts || [], data.scenes || []);

      } catch (e) {
        console.error('Load error:', e);
      }
    }

    function renderCharacters(characters) {
      const container = document.getElementById('charactersList');
      if (characters.length === 0) {
        container.innerHTML = '<div class="empty-list">No characters yet</div>';
        return;
      }
      container.innerHTML = characters.map(c => `
        <div class="list-item" onclick="editCharacter(${c.id})">
          <div class="list-item-name">${c.name || 'Unnamed'}</div>
          <div class="list-item-meta">${c.role || 'No role'}</div>
        </div>
      `).join('');
    }

    // Store acts for reference
    let currentActs = [];
    let currentScenes = [];

    function renderActsAndScenes(acts, scenes) {
      currentActs = acts || [];
      currentScenes = scenes || [];

      const container = document.getElementById('actsList');

      // Show helpful start state if nothing exists
      if (acts.length === 0 && scenes.length === 0) {
        container.innerHTML = `
          <div class="scenes-hint">
            <h4>Structure your story</h4>
            <p>Add acts to organize your scenes, or start with individual scenes.</p>
            <div class="scenes-hint-actions">
              <button class="scenes-hint-btn primary" onclick="createStandardActs()">Start with 3 Acts</button>
              <button class="scenes-hint-btn secondary" onclick="addScene()">Add a Scene</button>
            </div>
          </div>
        `;
        populateSceneSelector([]);
        return;
      }

      // Group scenes by act
      const scenesByAct = {};
      const unassignedScenes = [];

      scenes.forEach(s => {
        if (s.act_id) {
          if (!scenesByAct[s.act_id]) scenesByAct[s.act_id] = [];
          scenesByAct[s.act_id].push(s);
        } else {
          unassignedScenes.push(s);
        }
      });

      let html = '';

      // Render each act with its scenes
      acts.forEach(act => {
        const actScenes = scenesByAct[act.id] || [];
        const emptyState = `<div class="act-empty" onclick="addSceneToAct(${act.id})">+ Add scene to ${act.title}</div>`;

        html += `
          <div class="act-section" data-act-id="${act.id}">
            <div class="act-header" onclick="toggleAct(${act.id})">
              <div class="act-title-area">
                <span class="act-toggle">▼</span>
                <span class="act-title" ondblclick="event.stopPropagation(); editActTitle(${act.id})">${act.title}</span>
                <span class="act-scene-count">${actScenes.length} scene${actScenes.length !== 1 ? 's' : ''}</span>
              </div>
              <div class="act-actions">
                <button class="act-action-btn delete" onclick="event.stopPropagation(); deleteAct(${act.id}, '${act.title.replace(/'/g, "\\'")}')" title="Delete act">&times;</button>
              </div>
            </div>
            <div class="act-scenes">
              ${actScenes.length === 0 ? emptyState : actScenes.map(s => renderSceneItem(s)).join('')}
            </div>
          </div>
        `;
      });

      // Render unassigned scenes only if there are any
      if (unassignedScenes.length > 0) {
        html += `
          <div class="unassigned-section">
            <div class="unassigned-header">Unassigned</div>
            ${unassignedScenes.map(s => renderSceneItem(s)).join('')}
          </div>
        `;
      }

      container.innerHTML = html;

      // Also populate the canvas scene selector
      populateSceneSelector(scenes);

      // Setup drag-and-drop for scenes
      setupSceneDragAndDrop();
    }

    async function createStandardActs() {
      try {
        await fetch(`${API_BASE}/api/outline/acts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: 'Act 1 - Setup' })
        });
        await fetch(`${API_BASE}/api/outline/acts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: 'Act 2 - Confrontation' })
        });
        await fetch(`${API_BASE}/api/outline/acts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: 'Act 3 - Resolution' })
        });
        await loadOutline();
      } catch (e) {
        console.error('Failed to create acts:', e);
      }
    }

    function renderSceneItem(s) {
      const actBadge = s.act_id ? '' : '';
      return `
        <div class="list-item scene-item" draggable="true" data-scene-id="${s.id}" data-scene-number="${s.scene_number}" data-act-id="${s.act_id || ''}">
          <span class="scene-drag-handle" title="Drag to reorder">⋮⋮</span>
          <div class="list-item-content" onclick="openSceneInCanvas(${s.id})">
            <div class="list-item-name">${s.scene_number}. ${s.title || 'Untitled'}${actBadge}</div>
            <div class="list-item-meta">${s.description ? s.description.substring(0, 50) + '...' : 'No description'}</div>
          </div>
          <button class="scene-delete" onclick="event.stopPropagation(); deleteScene(${s.id}, '${(s.title || 'Untitled').replace(/'/g, "\\'")}')" title="Delete scene">&times;</button>
        </div>
      `;
    }

    function renderScenes(scenes) {
      // Legacy function - now calls renderActsAndScenes
      renderActsAndScenes(currentActs, scenes);
    }

    function toggleAct(actId) {
      const section = document.querySelector(`.act-section[data-act-id="${actId}"]`);
      if (section) {
        section.classList.toggle('collapsed');
      }
    }

    async function addAct() {
      try {
        const res = await fetch(`${API_BASE}/api/outline/acts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: `Act ${currentActs.length + 1}` })
        });
        const newAct = await res.json();
        currentActs.push(newAct);
        renderActsAndScenes(currentActs, currentScenes);
      } catch (e) {
        console.error('Failed to add act:', e);
      }
    }

    async function deleteAct(actId, title) {
      if (!confirm(`Delete "${title}"? Scenes will become unassigned.`)) return;
      try {
        await fetch(`${API_BASE}/api/outline/acts/${actId}`, { method: 'DELETE' });
        // Move scenes to unassigned
        currentScenes.forEach(s => {
          if (s.act_id === actId) s.act_id = null;
        });
        currentActs = currentActs.filter(a => a.id !== actId);
        renderActsAndScenes(currentActs, currentScenes);
      } catch (e) {
        console.error('Failed to delete act:', e);
      }
    }

    function editActTitle(actId) {
      const section = document.querySelector(`.act-section[data-act-id="${actId}"]`);
      const titleSpan = section.querySelector('.act-title');
      const currentTitle = titleSpan.textContent;

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'act-title-input';
      input.value = currentTitle;

      const saveTitle = async () => {
        const newTitle = input.value.trim() || currentTitle;
        titleSpan.textContent = newTitle;
        titleSpan.style.display = '';
        input.remove();

        try {
          await fetch(`${API_BASE}/api/outline/acts/${actId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: newTitle })
          });
          const act = currentActs.find(a => a.id === actId);
          if (act) act.title = newTitle;
        } catch (e) {
          console.error('Failed to update act title:', e);
        }
      };

      input.onblur = saveTitle;
      input.onkeydown = (e) => { if (e.key === 'Enter') saveTitle(); };

      titleSpan.style.display = 'none';
      titleSpan.parentNode.insertBefore(input, titleSpan.nextSibling);
      input.focus();
      input.select();
    }

    async function addSceneToAct(actId) {
      // Get next scene number
      const maxNum = currentScenes.reduce((max, s) => Math.max(max, s.scene_number), 0);
      const newNum = maxNum + 1;

      try {
        const res = await fetch(`${API_BASE}/api/outline/scenes`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ scene_number: newNum, title: '', act_id: actId })
        });
        const newScene = await res.json();
        currentScenes.push(newScene);
        renderActsAndScenes(currentActs, currentScenes);
        updateProjectProgress();
      } catch (e) {
        console.error('Failed to add scene:', e);
      }
    }

    function openSceneInCanvas(sceneId) {
      // Switch to canvas tab
      document.querySelectorAll('.outline-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      document.querySelector('[data-tab="canvas"]').classList.add('active');
      document.getElementById('panel-canvas').classList.add('active');

      // Select and load the scene
      document.getElementById('sceneSelector').value = sceneId;
      loadSceneToCanvas();
    }

    // ===================
    // PROJECT NAME EDIT
    // ===================
    function editProjectName() {
      const span = document.getElementById('projectName');
      const input = document.getElementById('projectNameInput');
      input.value = span.textContent === 'Untitled' ? '' : span.textContent;
      span.style.display = 'none';
      input.style.display = 'block';
      input.focus();
      input.select();
    }

    async function saveProjectName() {
      const span = document.getElementById('projectName');
      const input = document.getElementById('projectNameInput');
      const newTitle = input.value.trim() || 'Untitled';

      span.textContent = newTitle;
      span.style.display = 'inline';
      input.style.display = 'none';

      // Update the title input in the form too
      document.getElementById('title').value = newTitle === 'Untitled' ? '' : newTitle;

      // Save to server
      try {
        await fetch(`${API_BASE}/api/outline/project`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: newTitle === 'Untitled' ? '' : newTitle })
        });
        document.getElementById('saveStatus').textContent = 'Saved';
      } catch (e) {
        document.getElementById('saveStatus').textContent = 'Error';
      }
    }

    // ===================
    // AUTO-SAVE
    // ===================
    function setupAutoSave() {
      const fields = ['title', 'logline', 'description', 'theme', 'tone', 'comps', 'braindump'];
      fields.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener('input', () => {
            document.getElementById('saveStatus').textContent = 'Saving...';
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveOutline, 1000);
          });
        }
      });
    }

    async function saveOutline() {
      try {
        // Save project
        await fetch(`${API_BASE}/api/outline/project`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: document.getElementById('title').value,
            logline: document.getElementById('logline').value,
            description: document.getElementById('description').value
          })
        });

        // Save notes
        await fetch(`${API_BASE}/api/outline/notes`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            theme: document.getElementById('theme').value,
            tone: document.getElementById('tone').value,
            comps: document.getElementById('comps').value,
            braindump: document.getElementById('braindump').value
          })
        });

        document.getElementById('saveStatus').textContent = 'Save';
        document.getElementById('projectName').textContent = document.getElementById('title').value || 'Untitled';
      } catch (e) {
        document.getElementById('saveStatus').textContent = 'Error';
      }
    }

    async function manualSave() {
      document.getElementById('saveStatus').textContent = 'Saving...';
      try {
        await saveOutline();
        if (currentSceneId) {
          await saveCanvas();
        }
        document.getElementById('saveStatus').textContent = 'Saved!';
        setTimeout(() => {
          document.getElementById('saveStatus').textContent = 'Save';
        }, 2000);
      } catch (e) {
        document.getElementById('saveStatus').textContent = 'Error';
      }
    }

    // ===================
    // CHARACTER MODAL
    // ===================
    function addCharacter() {
      document.getElementById('characterModalTitle').textContent = 'Add Character';
      document.getElementById('characterId').value = '';
      document.getElementById('charName').value = '';
      document.getElementById('charRole').value = '';
      document.getElementById('charDescription').value = '';
      document.getElementById('charArc').value = '';
      document.getElementById('charFlaw').value = '';
      document.getElementById('deleteCharBtn').style.display = 'none';
      document.getElementById('characterModal').classList.remove('hidden');
      document.getElementById('charName').focus();
    }

    async function editCharacter(id) {
      try {
        const res = await fetch(`${API_BASE}/api/outline/characters/${id}`);
        if (!res.ok) throw new Error('Not found');
        const char = await res.json();

        document.getElementById('characterModalTitle').textContent = 'Edit Character';
        document.getElementById('characterId').value = id;
        document.getElementById('charName').value = char.name || '';
        document.getElementById('charRole').value = char.role || '';
        document.getElementById('charDescription').value = char.description || '';
        document.getElementById('charArc').value = char.arc || '';
        document.getElementById('charFlaw').value = char.flaw || '';
        document.getElementById('deleteCharBtn').style.display = 'block';
        document.getElementById('characterModal').classList.remove('hidden');
        document.getElementById('charName').focus();
      } catch (e) {
        alert('Failed to load character');
      }
    }

    function hideCharacterModal() {
      document.getElementById('characterModal').classList.add('hidden');
    }

    async function saveCharacter() {
      const id = document.getElementById('characterId').value;
      const data = {
        name: document.getElementById('charName').value.trim(),
        role: document.getElementById('charRole').value.trim(),
        description: document.getElementById('charDescription').value.trim(),
        arc: document.getElementById('charArc').value.trim(),
        flaw: document.getElementById('charFlaw').value.trim()
      };

      if (!data.name) {
        alert('Name is required');
        return;
      }

      try {
        if (id) {
          await fetch(`${API_BASE}/api/outline/characters/${id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
        } else {
          await fetch(`${API_BASE}/api/outline/characters`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
        }
        hideCharacterModal();
        await loadOutline();
      } catch (e) {
        alert('Failed to save character');
      }
    }

    async function deleteCharacter() {
      const id = document.getElementById('characterId').value;
      if (!id) return;
      if (!confirm('Delete this character?')) return;

      try {
        await fetch(`${API_BASE}/api/outline/characters/${id}`, { method: 'DELETE' });
        hideCharacterModal();
        await loadOutline();
      } catch (e) {
        alert('Failed to delete character');
      }
    }

    // Close modal on backdrop click
    document.getElementById('characterModal').addEventListener('click', (e) => {
      if (e.target.id === 'characterModal') hideCharacterModal();
    });

    async function addScene() {
      // Quick add: find next available scene number
      const nextNum = allScenes.length > 0 ? Math.max(...allScenes.map(s => s.scene_number)) + 1 : 1;
      try {
        await fetch(`${API_BASE}/api/outline/scenes`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ scene_number: nextNum, title: `Scene ${nextNum}` })
        });
        await loadOutline();
        // Open the new scene in canvas
        setTimeout(() => {
          const newScene = allScenes.find(s => s.scene_number === nextNum);
          if (newScene) openSceneInCanvas(newScene.id);
        }, 100);
      } catch (e) {
        alert('Failed to create scene');
      }
    }

    async function deleteScene(id, title) {
      if (!confirm(`Delete scene "${title}"? This cannot be undone.`)) return;
      try {
        await fetch(`${API_BASE}/api/outline/scenes/${id}`, { method: 'DELETE' });
        // If we deleted the current canvas scene, clear it
        if (currentSceneId === id) {
          currentSceneId = null;
          document.getElementById('sceneSelector').value = '';
          document.getElementById('canvasEmpty').style.display = 'flex';
          document.getElementById('screenplayContent').style.display = 'none';
        }
        await loadOutline();
      } catch (e) {
        alert('Failed to delete scene');
      }
    }

    function setupSceneDragAndDrop() {
      const container = document.getElementById('scenesList');
      const items = container.querySelectorAll('.scene-item');
      let draggedItem = null;

      items.forEach(item => {
        item.addEventListener('dragstart', (e) => {
          draggedItem = item;
          item.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', item.dataset.sceneId);
        });

        item.addEventListener('dragend', () => {
          item.classList.remove('dragging');
          items.forEach(i => i.classList.remove('drag-over'));
          draggedItem = null;
        });

        item.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          if (item !== draggedItem) {
            item.classList.add('drag-over');
          }
        });

        item.addEventListener('dragleave', () => {
          item.classList.remove('drag-over');
        });

        item.addEventListener('drop', async (e) => {
          e.preventDefault();
          item.classList.remove('drag-over');
          if (!draggedItem || item === draggedItem) return;

          const draggedId = parseInt(draggedItem.dataset.sceneId);
          const targetId = parseInt(item.dataset.sceneId);
          const targetNumber = parseInt(item.dataset.sceneNumber);

          // Reorder: move dragged scene to target's position
          try {
            await fetch(`${API_BASE}/api/outline/scenes/${draggedId}/reorder`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ new_scene_number: targetNumber })
            });
            await loadOutline();
          } catch (err) {
            console.error('Reorder failed:', err);
            alert('Failed to reorder scenes');
          }
        });
      });
    }

    // ===================
    // CHAT / BUCKETS
    // ===================
    async function checkBuckets() {
      try {
        const res = await fetch(`${API_BASE}/api/buckets`);
        if (res.ok) {
          const buckets = await res.json();
          buckets.forEach(b => {
            if (b.nodes > 0) availableBuckets[b.name] = true;
          });
          updateBucketChips();
        }
      } catch (e) {}
    }

    function updateBucketChips() {
      document.querySelectorAll('.bucket-chip').forEach(chip => {
        const bucket = chip.dataset.bucket;
        if (!availableBuckets[bucket]) {
          chip.classList.add('disabled');
        }
      });
    }

    function toggleBucket(bucket) {
      if (!availableBuckets[bucket]) return;

      const chip = document.querySelector(`[data-bucket="${bucket}"]`);
      const isActive = activeBuckets.includes(bucket);

      if (isActive) {
        activeBuckets = activeBuckets.filter(b => b !== bucket);
        chip.classList.remove('active');
        addSystemMessage(`${getBucketName(bucket)} deactivated`);
      } else {
        activeBuckets.push(bucket);
        chip.classList.add('active');
        addSystemMessage(`${getBucketName(bucket)} activated`);
      }
    }

    function getBucketName(bucket) {
      return { 'books-final': 'Books', 'plays-final': 'Plays', 'scripts-final': 'Scripts' }[bucket] || bucket;
    }

    // ===================
    // CONVERSATIONS
    // ===================
    async function loadConversations(autoSelectMostRecent = false) {
      try {
        const res = await fetch(`${API_BASE}/api/conversations`);
        if (res.ok) {
          conversations = await res.json();
          updateConversationSelect();

          // Auto-select most recent conversation if requested and one exists
          if (autoSelectMostRecent && conversations.length > 0 && !currentConversationId) {
            const mostRecent = conversations[0]; // Already sorted by updated_at desc
            currentConversationId = mostRecent.id;
            document.getElementById('conversationSelect').value = mostRecent.id;
            // Load the conversation messages
            const convRes = await fetch(`${API_BASE}/api/conversations/${mostRecent.id}`);
            if (convRes.ok) {
              const conv = await convRes.json();
              chatHistory = conv.messages || [];
              renderChatHistory();
              updateConvoButtons();
            }
          }
        }
      } catch (e) {
        console.error('Failed to load conversations:', e);
      }
    }

    function renderChatHistory() {
      const container = document.getElementById('messages');
      if (chatHistory.length === 0) {
        container.innerHTML = `
          <div class="chat-empty" id="chatEmpty">
            <h3>Ask Syd anything</h3>
            <p>Get help with your screenplay. Toggle knowledge sources above for domain expertise.</p>
          </div>`;
        return;
      }

      // Clear empty state and render messages
      container.innerHTML = '';
      chatHistory.forEach(msg => {
        addMessage(msg.role, msg.content);
      });
    }

    function updateConversationSelect() {
      const select = document.getElementById('conversationSelect');
      select.innerHTML = '<option value="">New Chat</option>';
      conversations.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c.id;
        opt.textContent = c.title;
        if (c.id === currentConversationId) opt.selected = true;
        select.appendChild(opt);
      });
    }

    async function loadConversation() {
      const select = document.getElementById('conversationSelect');
      const id = parseInt(select.value);

      if (!id) {
        // New chat selected
        newConversation();
        return;
      }

      try {
        const res = await fetch(`${API_BASE}/api/conversations/${id}`);
        if (res.ok) {
          const conv = await res.json();
          currentConversationId = conv.id;
          chatHistory = conv.messages || [];

          // Render messages
          const container = document.getElementById('messages');
          container.innerHTML = '';

          if (chatHistory.length === 0) {
            container.innerHTML = `
              <div class="chat-empty" id="chatEmpty">
                <h3>Ask Syd anything</h3>
                <p>Get help with your screenplay. Toggle knowledge sources above for domain expertise.</p>
              </div>`;
          } else {
            chatHistory.forEach(msg => addMessage(msg.role, msg.content));
          }
          updateConvoButtons();
        }
      } catch (e) {
        console.error('Failed to load conversation:', e);
      }
    }

    function newConversation() {
      currentConversationId = null;
      chatHistory = [];
      document.getElementById('conversationSelect').value = '';
      document.getElementById('messages').innerHTML = `
        <div class="chat-empty" id="chatEmpty">
          <h3>Ask Syd anything</h3>
          <p>Get help with your screenplay. Toggle knowledge sources above for domain expertise.</p>
        </div>`;
      updateConvoButtons();
    }

    async function renameConversation() {
      if (!currentConversationId) return;

      const conv = conversations.find(c => c.id === currentConversationId);
      if (!conv) return;

      const newTitle = prompt('Rename conversation:', conv.title);
      if (newTitle === null || newTitle.trim() === '') return;

      try {
        const res = await fetch(`${API_BASE}/api/conversations/${currentConversationId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: newTitle.trim() })
        });
        if (res.ok) {
          await loadConversations();
          document.getElementById('conversationSelect').value = currentConversationId;
        }
      } catch (e) {
        console.error('Failed to rename conversation:', e);
      }
    }

    async function deleteConversation() {
      if (!currentConversationId) return;

      if (!confirm('Delete this conversation?')) return;

      try {
        const res = await fetch(`${API_BASE}/api/conversations/${currentConversationId}`, {
          method: 'DELETE'
        });
        if (res.ok) {
          newConversation();
          await loadConversations();
        }
      } catch (e) {
        console.error('Failed to delete conversation:', e);
      }
    }

    function updateConvoButtons() {
      const hasConvo = !!currentConversationId;
      document.getElementById('renameConvoBtn').disabled = !hasConvo;
      document.getElementById('deleteConvoBtn').disabled = !hasConvo;
    }

    async function saveConversation() {
      if (chatHistory.length === 0) return;

      // Generate title from first user message
      const firstUserMsg = chatHistory.find(m => m.role === 'user');
      const title = firstUserMsg ? firstUserMsg.content.slice(0, 40) + (firstUserMsg.content.length > 40 ? '...' : '') : 'New Chat';

      try {
        if (currentConversationId) {
          // Update existing
          await fetch(`${API_BASE}/api/conversations/${currentConversationId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: chatHistory })
          });
        } else {
          // Create new
          const res = await fetch(`${API_BASE}/api/conversations`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title, messages: chatHistory })
          });
          if (res.ok) {
            const conv = await res.json();
            currentConversationId = conv.id;
            await loadConversations();
          }
        }
      } catch (e) {
        console.error('Failed to save conversation:', e);
      }
    }

    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    async function sendMessage() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      if (!message) return;

      input.value = '';
      input.disabled = true;
      document.getElementById('sendBtn').disabled = true;

      // Clear empty state
      const empty = document.getElementById('chatEmpty');
      if (empty) empty.remove();

      addMessage('user', message);
      const loadingId = addMessage('assistant', '<div class="loading-dots"><span></span><span></span><span></span></div>', true);

      try {
        const systemPrompt = buildSystemPrompt();
        const response = await fetch(`${API_BASE}/api/expert/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message,
            bucket: activeBuckets[0] || 'scripts-final',
            system_prompt: systemPrompt,
            rag_mode: 'hybrid',
            history: chatHistory.slice(-10)
          })
        });

        removeMessage(loadingId);
        // Clean up any stray loading messages
        document.querySelectorAll('.loading-message').forEach(el => el.remove());

        if (response.ok) {
          const data = await response.json();
          addMessage('assistant', data.response);
          chatHistory.push({ role: 'user', content: message });
          chatHistory.push({ role: 'assistant', content: data.response });

          // Save conversation
          await saveConversation();

          // If Syd used tools, refresh the outline
          if (data.tools_used && data.tools_used.length > 0) {
            console.log('Syd used tools:', data.tools_used);
            addSystemMessage('Outline updated');
            await loadOutline();
          }
        } else {
          addMessage('system', 'Error getting response');
        }
      } catch (e) {
        removeMessage(loadingId);
        document.querySelectorAll('.loading-message').forEach(el => el.remove());
        addMessage('system', 'Connection error');
      }

      input.disabled = false;
      document.getElementById('sendBtn').disabled = false;
      input.focus();
    }

    function buildSystemPrompt() {
      // Get project context
      const title = document.getElementById('title').value;
      const logline = document.getElementById('logline').value;
      const theme = document.getElementById('theme')?.value || '';

      // Adaptive prompt based on project state, not rigid phases
      let prompt = `You are Syd, an expert romantic comedy collaborator. You know the genre deeply—
from Shakespeare's comedies to modern classics, from Save the Cat to Robert McKee.

YOUR APPROACH:
- Follow the writer's lead. They might want to explore ideas, build structure, or write scenes.
- Respond to what they're actually saying, not what phase they "should" be in.
- If they're excited about an idea, explore it with them.
- If they're stuck on structure, help them find it.
- If they're writing dialogue, help with craft.
- Ask ONE question at a time. React → Build → Ask.

YOU CAN:
- Help discover and develop ideas (ask questions, reflect back, find the spark)
- Build characters (flaws, arcs, chemistry, relationships)
- Develop structure (beats, turning points, the romcom framework)
- Write scenes (action lines, dialogue, subtext, pacing)
- Use your tools to update the outline when the writer wants to capture something

THE PROJECT:`;

      // Add what exists
      if (title) prompt += `\nTitle: ${title}`;
      if (logline) prompt += `\nLogline: ${logline}`;
      if (theme) prompt += `\nTheme: ${theme}`;

      // Describe project state
      prompt += `\n\nPROJECT STATE:`;
      if (!projectState.hasTitle && !projectState.hasLogline) {
        prompt += `\n- Just getting started - no title or logline yet`;
      } else if (!projectState.hasLogline) {
        prompt += `\n- Has a title but no logline`;
      }
      prompt += `\n- ${projectState.characterCount} characters defined`;
      prompt += `\n- ${projectState.sceneCount} scenes outlined`;
      if (projectState.scenesWithContent > 0) {
        prompt += `\n- ${projectState.scenesWithContent} scenes have draft content`;
      }

      // Suggest focus based on what's missing (but don't enforce)
      if (!projectState.hasLogline) {
        prompt += `\n\n(The logline might be worth exploring - but follow the writer's lead.)`;
      } else if (projectState.characterCount < 2) {
        prompt += `\n\n(Characters could use development - but follow the writer's lead.)`;
      } else if (projectState.sceneCount < 5) {
        prompt += `\n\n(Structure is sparse - but follow the writer's lead.)`;
      }

      prompt += `\n\nKnowledge buckets available:
- books-final (Structure): act breaks, midpoints, pacing
- plays-final (Dialogue): subtext, banter, confrontations
- scripts-final (Execution): writing scenes, meet-cutes, tone`;

      if (activeBuckets.length > 0) {
        prompt += `\n\nACTIVE: ${activeBuckets.map(getBucketName).join(', ')}. Query freely.`;
      }

      return prompt;
    }

    function addMessage(role, content, isHtml = false) {
      const container = document.getElementById('messages');
      const id = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
      const div = document.createElement('div');
      div.id = id;
      div.className = `message ${role}`;
      if (isHtml && content.includes('loading-dots')) {
        div.classList.add('loading-message');
      }

      if (isHtml) {
        div.innerHTML = content;
      } else {
        let html = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\n/g, '<br>');
        div.innerHTML = html;
      }

      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
      return id;
    }

    function addSystemMessage(text) {
      const empty = document.getElementById('chatEmpty');
      if (empty) empty.remove();
      addMessage('system', text);
    }

    function removeMessage(id) {
      const msg = document.getElementById(id);
      if (msg) msg.remove();
    }

    // ===================
    // CANVAS
    // ===================
    let allScenes = [];
    let currentSceneId = null;
    let canvasElements = [];

    function populateSceneSelector(scenes) {
      allScenes = scenes;
      const selector = document.getElementById('sceneSelector');
      selector.innerHTML = '<option value="">Select a scene...</option>';

      scenes.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = `${s.scene_number}. ${s.title || 'Untitled'}`;
        selector.appendChild(opt);
      });

      updateNavButtons();
    }

    function loadSceneToCanvas() {
      const sceneId = parseInt(document.getElementById('sceneSelector').value);
      if (!sceneId) {
        document.getElementById('canvasEmpty').style.display = 'flex';
        document.getElementById('screenplayContent').style.display = 'none';
        currentSceneId = null;
        updateNavButtons();
        return;
      }

      currentSceneId = sceneId;
      const scene = allScenes.find(s => s.id === sceneId);
      if (!scene) return;

      // Show canvas content
      document.getElementById('canvasEmpty').style.display = 'none';
      document.getElementById('screenplayContent').style.display = 'block';

      // Parse scene heading from title or use defaults
      const heading = parseSceneHeading(scene.title || '');
      document.getElementById('sceneIntExt').value = heading.intExt;
      document.getElementById('sceneLocation').value = heading.location;
      document.getElementById('sceneTime').value = heading.time;

      // Load screenplay content if stored
      loadCanvasContent(scene);

      updateNavButtons();
      document.getElementById('canvasStatus').textContent = '';
    }

    function parseSceneHeading(title) {
      // Try to parse "INT. COFFEE SHOP - DAY" format
      const match = title.match(/^(INT\.|EXT\.|INT\.\/EXT\.)\s*(.+?)\s*-\s*(.+)$/i);
      if (match) {
        return {
          intExt: match[1].toUpperCase(),
          location: match[2].trim().toUpperCase(),
          time: match[3].trim().toUpperCase()
        };
      }
      // Default
      return {
        intExt: 'INT.',
        location: title.toUpperCase() || '',
        time: 'DAY'
      };
    }

    function loadCanvasContent(scene) {
      const body = document.getElementById('screenplayBody');
      body.innerHTML = '';
      canvasElements = [];

      // If scene has stored canvas_content, parse and load it
      if (scene.canvas_content) {
        try {
          const content = JSON.parse(scene.canvas_content);
          content.forEach(el => addElement(el.type, el.text));
        } catch (e) {
          // If no canvas content, start with action from description
          if (scene.description) {
            addElement('action', scene.description);
          }
        }
      } else if (scene.description) {
        // Start with description as action
        addElement('action', scene.description);
      }
    }

    function addElement(type, text = '') {
      const body = document.getElementById('screenplayBody');
      const id = 'elem-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);

      const div = document.createElement('div');
      div.id = id;
      div.className = `screenplay-element element-${type}`;
      div.dataset.type = type;

      let input;
      switch (type) {
        case 'action':
          input = document.createElement('textarea');
          input.placeholder = 'Action description...';
          input.value = text;
          input.rows = 2;
          break;
        case 'character':
          input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'CHARACTER NAME';
          input.value = text;
          break;
        case 'dialogue':
          input = document.createElement('textarea');
          input.placeholder = 'Dialogue...';
          input.value = text;
          input.rows = 2;
          break;
        case 'parenthetical':
          input = document.createElement('input');
          input.type = 'text';
          input.placeholder = '(beat)';
          input.value = text || '(';
          // Auto-add parentheses
          input.addEventListener('focus', () => {
            if (!input.value.startsWith('(')) input.value = '(' + input.value;
          });
          input.addEventListener('blur', () => {
            if (!input.value.endsWith(')') && input.value.length > 1) input.value += ')';
          });
          break;
        case 'transition':
          input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'CUT TO:';
          input.value = text;
          break;
      }

      input.dataset.elemId = id;
      div.appendChild(input);

      // Delete button
      const del = document.createElement('button');
      del.className = 'element-delete';
      del.textContent = '×';
      del.onclick = () => removeElement(id);
      div.appendChild(del);

      body.appendChild(div);
      canvasElements.push({ id, type });

      // Focus the new element
      input.focus();

      return id;
    }

    function removeElement(id) {
      const elem = document.getElementById(id);
      if (elem) {
        elem.remove();
        canvasElements = canvasElements.filter(e => e.id !== id);
      }
    }

    function prevScene() {
      const currentIdx = allScenes.findIndex(s => s.id === currentSceneId);
      if (currentIdx > 0) {
        document.getElementById('sceneSelector').value = allScenes[currentIdx - 1].id;
        loadSceneToCanvas();
      }
    }

    function nextScene() {
      const currentIdx = allScenes.findIndex(s => s.id === currentSceneId);
      if (currentIdx < allScenes.length - 1) {
        document.getElementById('sceneSelector').value = allScenes[currentIdx + 1].id;
        loadSceneToCanvas();
      }
    }

    function updateNavButtons() {
      const currentIdx = allScenes.findIndex(s => s.id === currentSceneId);
      document.getElementById('prevSceneBtn').disabled = currentIdx <= 0;
      document.getElementById('nextSceneBtn').disabled = currentIdx >= allScenes.length - 1 || currentIdx < 0;
    }

    async function saveCanvas() {
      if (!currentSceneId) return;

      document.getElementById('canvasStatus').textContent = 'Saving...';

      // Build scene heading
      const intExt = document.getElementById('sceneIntExt').value;
      const location = document.getElementById('sceneLocation').value;
      const time = document.getElementById('sceneTime').value;
      const title = `${intExt} ${location} - ${time}`;

      // Gather canvas elements
      const content = [];
      document.querySelectorAll('#screenplayBody .screenplay-element').forEach(elem => {
        const type = elem.dataset.type;
        const input = elem.querySelector('input, textarea');
        if (input && input.value.trim()) {
          content.push({ type, text: input.value.trim() });
        }
      });

      try {
        await fetch(`${API_BASE}/api/outline/scenes/${currentSceneId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title,
            canvas_content: JSON.stringify(content)
          })
        });

        document.getElementById('canvasStatus').textContent = 'Saved';

        // Update scene selector label
        const opt = document.querySelector(`#sceneSelector option[value="${currentSceneId}"]`);
        if (opt) {
          const scene = allScenes.find(s => s.id === currentSceneId);
          if (scene) {
            scene.title = title;
            opt.textContent = `${scene.scene_number}. ${title}`;
          }
        }

        // Reload scenes list
        loadOutline();
      } catch (e) {
        document.getElementById('canvasStatus').textContent = 'Error saving';
      }
    }

    // ===================
    // INIT
    // ===================
    loadOutline();
    checkBuckets();
    setupAutoSave();
    loadConversations(true); // Auto-select most recent conversation

    // Auto-save canvas every 10 seconds
    setInterval(() => {
      if (currentSceneId) {
        saveCanvas();
        console.log('Canvas auto-saved');
      }
    }, 10000);

    // Trigger Hindsight reflection when leaving the page
    window.addEventListener('beforeunload', () => {
      // Use sendBeacon for reliable delivery on page unload
      navigator.sendBeacon(`${API_BASE}/api/reflect`, '');
    });
  </script>
</body>
</html>
