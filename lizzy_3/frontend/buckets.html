<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lizzy - Knowledge Buckets</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root { --transition: 0.25s ease; }

    [data-theme="light"] {
      --bg-primary: #fff;
      --bg-secondary: #fafafa;
      --bg-tertiary: #f4f4f5;
      --bg-inverse: #111;
      --text-primary: #111;
      --text-secondary: #52525b;
      --text-muted: #71717a;
      --text-inverse: #fff;
      --border: #e4e4e7;
      --border-light: #f4f4f5;
      --shadow: rgba(0,0,0,0.08);
      --danger: #dc2626;
      --danger-bg: #fef2f2;
      --success: #22c55e;
      --success-bg: #f0fdf4;
      --accent: #3b82f6;
      --accent-bg: #eff6ff;
    }

    [data-theme="dark"] {
      --bg-primary: #18181b;
      --bg-secondary: #111;
      --bg-tertiary: #27272a;
      --bg-inverse: #fafafa;
      --text-primary: #fafafa;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;
      --text-inverse: #111;
      --border: #3f3f46;
      --border-light: #27272a;
      --shadow: rgba(0,0,0,0.4);
      --danger: #f87171;
      --danger-bg: #1c1917;
      --success: #4ade80;
      --success-bg: #14532d20;
      --accent: #60a5fa;
      --accent-bg: #1e3a5f;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      background: var(--bg-secondary);
      color: var(--text-primary);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      transition: background var(--transition), color var(--transition);
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem 1.5rem 4rem;
    }

    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 2rem;
    }

    .page-header h1 {
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .header-links {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-links a {
      font-size: 0.875rem;
      color: var(--text-muted);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    .header-links a:hover { color: var(--text-primary); }

    .theme-toggle { display: flex; align-items: center; gap: 0.5rem; }
    .theme-toggle span { font-size: 0.75rem; color: var(--text-muted); }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      cursor: pointer;
      transition: background var(--transition);
      border: 1px solid var(--border);
    }

    .toggle-switch::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 16px;
      height: 16px;
      background: var(--text-primary);
      border-radius: 50%;
      transition: transform 0.25s ease, background var(--transition);
    }

    [data-theme="dark"] .toggle-switch::after { transform: translateX(20px); }

    /* Bucket Grid */
    .buckets-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .bucket-card {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 1.25rem;
      transition: all 0.2s ease;
    }

    .bucket-card:hover {
      border-color: var(--text-muted);
      box-shadow: 0 4px 12px var(--shadow);
    }

    .bucket-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      margin-bottom: 1rem;
    }

    .bucket-name {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .bucket-status {
      font-size: 0.6875rem;
      font-weight: 500;
      padding: 0.25rem 0.5rem;
      border-radius: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .bucket-status.loaded {
      background: var(--success-bg);
      color: var(--success);
    }

    .bucket-status.pending {
      background: var(--accent-bg);
      color: var(--accent);
    }

    .bucket-status.error {
      background: var(--danger-bg);
      color: var(--danger);
    }

    .bucket-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .stat {
      text-align: center;
      padding: 0.5rem;
      background: var(--bg-secondary);
      border-radius: 0.5rem;
    }

    .stat-value {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .stat-label {
      font-size: 0.6875rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .bucket-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.375rem;
    }

    .bucket-actions button {
      font-size: 0.75rem;
      padding: 0.375rem 0.5rem;
    }

    .bucket-actions .btn-danger {
      grid-column: span 2;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 0.6875rem;
    }

    .bucket-actions .btn-danger:hover {
      border-color: var(--danger);
      color: var(--danger);
      background: var(--danger-bg);
    }

    /* Buttons */
    .btn {
      padding: 0.5rem 0.875rem;
      border-radius: 0.5rem;
      font-family: inherit;
      font-size: 0.8125rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }

    .btn-primary {
      background: var(--bg-inverse);
      color: var(--text-inverse);
    }

    .btn-primary:hover { opacity: 0.9; }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border-color: var(--border);
    }

    .btn-secondary:hover {
      border-color: var(--text-primary);
    }

    .btn-danger {
      background: var(--danger-bg);
      color: var(--danger);
    }

    .btn-danger:hover {
      background: var(--danger);
      color: var(--bg-primary);
    }

    .btn-icon {
      padding: 0.5rem;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 0.375rem;
      transition: all 0.2s ease;
    }

    .btn-icon:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* Create Bucket Card */
    .create-card {
      background: var(--bg-primary);
      border: 2px dashed var(--border);
      border-radius: 0.75rem;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 180px;
    }

    .create-card:hover {
      border-color: var(--text-muted);
      background: var(--bg-secondary);
    }

    .create-card .icon {
      font-size: 2rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .create-card span {
      font-size: 0.875rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    /* Sections */
    .section {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      margin-bottom: 1.5rem;
      overflow: hidden;
    }

    .section-header {
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .section-header h2 {
      font-size: 0.875rem;
      font-weight: 600;
    }

    .section-body {
      padding: 1.25rem;
    }

    /* Drop Zone */
    .drop-zone {
      border: 2px dashed var(--border);
      border-radius: 0.5rem;
      padding: 2.5rem 1.5rem;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .drop-zone:hover,
    .drop-zone.dragover {
      border-color: var(--accent);
      background: var(--accent-bg);
    }

    .drop-zone .icon {
      font-size: 2.5rem;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
    }

    .drop-zone h3 {
      font-size: 0.9375rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .drop-zone p {
      font-size: 0.8125rem;
      color: var(--text-muted);
    }

    .drop-zone input[type="file"] {
      display: none;
    }

    /* Folder Input */
    .folder-input {
      display: flex;
      gap: 0.75rem;
      margin-top: 1rem;
    }

    .folder-input input {
      flex: 1;
      padding: 0.625rem 0.875rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: "SF Mono", Monaco, "Courier New", monospace;
      font-size: 0.8125rem;
    }

    .folder-input input:focus {
      outline: none;
      border-color: var(--text-primary);
    }

    .folder-input input::placeholder {
      color: var(--text-muted);
    }

    /* File List */
    .file-list {
      margin-top: 1rem;
      max-height: 200px;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      background: var(--bg-secondary);
      border-radius: 0.375rem;
      margin-bottom: 0.375rem;
      font-size: 0.8125rem;
    }

    .file-item .name {
      font-family: "SF Mono", Monaco, monospace;
      color: var(--text-primary);
    }

    .file-item .size {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--bg-primary);
      border-radius: 0.75rem;
      width: 90%;
      max-width: 480px;
      max-height: 90vh;
      overflow: auto;
      transform: scale(0.95);
      transition: transform 0.2s ease;
    }

    .modal-overlay.active .modal {
      transform: scale(1);
    }

    .modal-header {
      padding: 1.25rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-header h2 {
      font-size: 1.125rem;
      font-weight: 600;
    }

    .modal-body {
      padding: 1.25rem;
    }

    .modal-footer {
      padding: 1rem 1.25rem;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      font-size: 0.8125rem;
      font-weight: 500;
      margin-bottom: 0.375rem;
    }

    .form-group input,
    .form-group textarea {
      width: 100%;
      padding: 0.625rem 0.875rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 0.875rem;
    }

    .form-group input:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: var(--text-primary);
    }

    .form-group textarea {
      resize: vertical;
      min-height: 80px;
    }

    .form-hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.25rem;
    }

    /* Progress */
    .progress-bar {
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 1rem;
    }

    .progress-bar .fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 0.5rem;
      text-align: center;
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 3rem 1.5rem;
      color: var(--text-muted);
    }

    .empty-state .icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .empty-state h3 {
      font-size: 1rem;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }

    .empty-state p {
      font-size: 0.875rem;
      max-width: 300px;
      margin: 0 auto;
    }

    @media (max-width: 600px) {
      .buckets-grid {
        grid-template-columns: 1fr;
      }

      .bucket-stats {
        grid-template-columns: repeat(3, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="page-header">
      <h1>Knowledge Buckets</h1>
      <div class="header-links">
        <a href="outline.html">Outline</a>
        <a href="query.html">Query</a>
        <a href="buckets.html">Buckets</a>
        <div class="theme-toggle">
          <span>&#9788;</span>
          <div class="toggle-switch" id="themeToggle"></div>
          <span>&#9790;</span>
        </div>
      </div>
    </div>

    <!-- Buckets Grid -->
    <div class="buckets-grid" id="bucketsGrid">
      <!-- Bucket cards will be populated by JS -->

      <!-- Create New Card -->
      <div class="create-card" id="createBucketBtn">
        <div class="icon">+</div>
        <span>Create New Bucket</span>
      </div>
    </div>

    <!-- Import Section -->
    <div class="section" id="importSection" style="display: none;">
      <div class="section-header">
        <h2>Import Documents</h2>
        <select id="targetBucket" class="btn btn-secondary" style="padding: 0.375rem 0.75rem;">
          <option value="">Select bucket...</option>
        </select>
      </div>
      <div class="section-body">
        <div class="drop-zone" id="dropZone">
          <div class="icon">&#128196;</div>
          <h3>Drop files here</h3>
          <p>or click to browse (.txt, .pdf, .md, .html)</p>
          <input type="file" id="fileInput" multiple accept=".txt,.pdf,.md,.html">
        </div>

        <div class="folder-input">
          <input type="text" id="folderPath" placeholder="/path/to/documents/folder">
          <button class="btn btn-secondary" id="importFolderBtn">Import Folder</button>
        </div>
      </div>
    </div>

    <!-- Upload Queue -->
    <div class="section" id="queueSection" style="display: none;">
      <div class="section-header">
        <h2>Upload Queue</h2>
        <span class="queue-count" id="queueCount">0/0</span>
      </div>
      <div class="queue-list" id="queueList"></div>
    </div>

  </div>

  <!-- Create Bucket Modal -->
  <div class="modal-overlay" id="createModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Create New Bucket</h2>
        <button class="btn-icon" onclick="closeModal('createModal')">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="bucketName">Bucket Name</label>
          <input type="text" id="bucketName" placeholder="e.g., my-research">
          <p class="form-hint">Lowercase letters, numbers, and hyphens only</p>
        </div>
        <div class="form-group">
          <label for="bucketDesc">Description (optional)</label>
          <textarea id="bucketDesc" placeholder="What kind of knowledge will this bucket contain?"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('createModal')">Cancel</button>
        <button class="btn btn-primary" onclick="createBucket()">Create Bucket</button>
      </div>
    </div>
  </div>

  <!-- Delete Confirmation Modal -->
  <div class="modal-overlay" id="deleteModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Delete Bucket</h2>
        <button class="btn-icon" onclick="closeModal('deleteModal')">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--text-secondary);">
          Are you sure you want to delete <strong id="deleteBucketName"></strong>?
          This will permanently remove all indexed documents and knowledge graphs.
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('deleteModal')">Cancel</button>
        <button class="btn btn-danger" onclick="confirmDelete()">Delete Bucket</button>
      </div>
    </div>
  </div>

  <!-- Documents Modal -->
  <div class="modal-overlay" id="docsModal">
    <div class="modal" style="max-width: 640px;">
      <div class="modal-header">
        <h2>Documents in <span id="docsBucketName"></span></h2>
        <button class="btn-icon" onclick="closeModal('docsModal')">&times;</button>
      </div>
      <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
        <div id="docsLoading" style="text-align: center; padding: 2rem; color: var(--text-muted);">
          Loading documents...
        </div>
        <div id="docsList"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('docsModal')">Close</button>
      </div>
    </div>
  </div>

  <!-- Graph Stats Modal -->
  <div class="modal-overlay" id="graphModal">
    <div class="modal" style="max-width: 400px;">
      <div class="modal-header">
        <h2>Graph: <span id="graphBucketName"></span></h2>
        <button class="btn-icon" onclick="closeModal('graphModal')">&times;</button>
      </div>
      <div class="modal-body">
        <div id="graphContent"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('graphModal')">Close</button>
        <button class="btn btn-primary" onclick="window.open('http://localhost:7474','_blank')">Open Neo4j</button>
      </div>
    </div>
  </div>

  <!-- Query Results Modal -->
  <div class="modal-overlay" id="queryModal">
    <div class="modal" style="max-width: 700px;">
      <div class="modal-header">
        <h2>Query: <span id="queryBucketName"></span></h2>
        <button class="btn-icon" onclick="closeModal('queryModal')">&times;</button>
      </div>
      <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
        <div id="queryContent"></div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeModal('queryModal')">Close</button>
      </div>
    </div>
  </div>

  <style>
    .doc-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
    }
    .doc-item:last-child {
      border-bottom: none;
    }
    .doc-title {
      font-weight: 500;
      font-size: 0.875rem;
    }
    .doc-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.75rem;
      color: var(--text-muted);
    }
    .doc-preview {
      display: none;
    }
    .doc-status {
      display: inline-block;
      font-size: 0.625rem;
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      background: var(--success-bg);
      color: var(--success);
      text-transform: uppercase;
      font-weight: 500;
    }
    .doc-status.processing {
      background: var(--bg-tertiary);
      color: #eab308;
    }
    .doc-status.pending {
      background: var(--bg-tertiary);
      color: #ef4444;
    }
    .doc-item.stuck {
      opacity: 0.5;
    }
    .stuck-warning {
      background: var(--danger-bg);
      border: 1px solid var(--danger);
      border-radius: 0.5rem;
      padding: 0.75rem 1rem;
      margin-bottom: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8125rem;
    }
    .stuck-warning span {
      color: var(--danger);
    }
    .stuck-warning button {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }

    /* Queue styles */
    .queue-count {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-weight: 500;
    }
    .queue-list {
      max-height: 400px;
      overflow-y: auto;
    }
    .queue-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.875rem 1.25rem;
      border-bottom: 1px solid var(--border-light);
    }
    .queue-item:last-child {
      border-bottom: none;
    }
    .queue-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      flex-shrink: 0;
    }
    .queue-icon.done { color: var(--success); }
    .queue-icon.processing { color: var(--accent); }
    .queue-icon.queued { color: var(--text-muted); }
    .queue-icon.error { color: var(--danger); }
    .queue-info {
      flex: 1;
      min-width: 0;
    }
    .queue-name {
      font-size: 0.875rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .queue-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      gap: 0.75rem;
      margin-top: 0.125rem;
    }
    .queue-progress {
      width: 120px;
      flex-shrink: 0;
    }
    .queue-progress-bar {
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      overflow: hidden;
    }
    .queue-progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    .queue-progress-text {
      font-size: 0.6875rem;
      color: var(--text-muted);
      text-align: right;
      margin-top: 0.25rem;
    }
    .queue-action {
      flex-shrink: 0;
    }
    .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .validation-error {
      background: var(--danger-bg);
    }
    .validation-error .queue-name {
      color: var(--danger);
    }
  </style>

  <script>
    // Theme handling
    const html = document.documentElement;
    const themeToggle = document.getElementById('themeToggle');
    const savedTheme = localStorage.getItem('theme') || 'light';
    html.setAttribute('data-theme', savedTheme);

    themeToggle.addEventListener('click', () => {
      const current = html.getAttribute('data-theme');
      const next = current === 'light' ? 'dark' : 'light';
      html.setAttribute('data-theme', next);
      localStorage.setItem('theme', next);
    });

    // State
    let buckets = [];
    let pendingDeleteBucket = null;
    const API_BASE = 'http://localhost:8000';

    // Load buckets on page load
    async function loadBuckets() {
      try {
        const response = await fetch(`${API_BASE}/api/buckets`);
        if (response.ok) {
          buckets = await response.json();
          renderBuckets();
          updateImportSection();
        }
      } catch (e) {
        console.log('API not available, showing empty state');
        renderBuckets();
      }
    }

    function renderBuckets() {
      const grid = document.getElementById('bucketsGrid');
      const createCard = document.getElementById('createBucketBtn');

      // Clear existing bucket cards (keep create card)
      grid.querySelectorAll('.bucket-card').forEach(el => el.remove());

      buckets.forEach(bucket => {
        const card = document.createElement('div');
        card.className = 'bucket-card';
        card.innerHTML = `
          <div class="bucket-header">
            <div>
              <div class="bucket-name">${bucket.name}</div>
            </div>
            <span class="bucket-status ${bucket.status}">${bucket.status}</span>
          </div>
          <div class="bucket-stats">
            <div class="stat">
              <div class="stat-value">${formatNumber(bucket.nodes || 0)}</div>
              <div class="stat-label">Nodes</div>
            </div>
            <div class="stat">
              <div class="stat-value">${formatNumber(bucket.edges || 0)}</div>
              <div class="stat-label">Edges</div>
            </div>
            <div class="stat">
              <div class="stat-value">${formatSize(bucket.size || 0)}</div>
              <div class="stat-label">Size</div>
            </div>
          </div>
          <div class="bucket-actions">
            <button class="btn btn-secondary" onclick="showDocuments('${bucket.name}')">Docs</button>
            <button class="btn btn-secondary" onclick="selectBucketForImport('${bucket.name}')">Add Docs</button>
            <button class="btn btn-secondary" onclick="viewGraph('${bucket.name}')" ${bucket.nodes > 0 ? '' : 'disabled'}>Graph</button>
            <button class="btn btn-secondary" onclick="queryBucket('${bucket.name}')" ${bucket.nodes > 0 ? '' : 'disabled'}>Query</button>
            <button class="btn btn-danger" onclick="showDeleteModal('${bucket.name}')">Delete Bucket</button>
          </div>
        `;
        grid.insertBefore(card, createCard);
      });
    }

    function formatNumber(n) {
      if (n >= 1000) return (n / 1000).toFixed(1) + 'k';
      return n.toString();
    }

    function formatSize(bytes) {
      if (bytes >= 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + 'MB';
      if (bytes >= 1024) return (bytes / 1024).toFixed(1) + 'KB';
      return bytes + 'B';
    }

    function updateImportSection() {
      const select = document.getElementById('targetBucket');
      select.innerHTML = '<option value="">Select bucket...</option>';
      buckets.forEach(b => {
        select.innerHTML += `<option value="${b.name}">${b.name}</option>`;
      });

      document.getElementById('importSection').style.display = buckets.length > 0 ? 'block' : 'none';
    }

    // Modal handling
    function openModal(id) {
      document.getElementById(id).classList.add('active');
    }

    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
    }

    document.getElementById('createBucketBtn').onclick = () => openModal('createModal');

    async function createBucket() {
      const name = document.getElementById('bucketName').value.trim().toLowerCase().replace(/[^a-z0-9-]/g, '-');
      const description = document.getElementById('bucketDesc').value.trim();

      if (!name) {
        alert('Please enter a bucket name');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/buckets`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, description })
        });

        if (response.ok) {
          closeModal('createModal');
          document.getElementById('bucketName').value = '';
          document.getElementById('bucketDesc').value = '';
          loadBuckets();
        } else {
          const error = await response.json();
          alert(error.detail || 'Failed to create bucket');
        }
      } catch (e) {
        // Mock for frontend testing
        buckets.push({
          name,
          status: 'pending',
          nodes: 0,
          edges: 0,
          size: 0
        });
        closeModal('createModal');
        document.getElementById('bucketName').value = '';
        document.getElementById('bucketDesc').value = '';
        renderBuckets();
        updateImportSection();
      }
    }

    async function showDocuments(bucketName) {
      document.getElementById('docsBucketName').textContent = bucketName;
      document.getElementById('docsLoading').style.display = 'block';
      document.getElementById('docsList').innerHTML = '';
      openModal('docsModal');

      try {
        const response = await fetch(`${API_BASE}/api/buckets/${bucketName}/documents`);
        if (response.ok) {
          const docs = await response.json();
          document.getElementById('docsLoading').style.display = 'none';

          if (docs.length === 0) {
            document.getElementById('docsList').innerHTML = `
              <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                No documents in this bucket yet.
              </div>
            `;
            return;
          }

          document.getElementById('docsList').innerHTML = docs.map(doc => `
            <div class="doc-item">
              <div class="doc-title">${escapeHtml(doc.title)}</div>
              <div class="doc-meta">
                <span class="doc-status ${doc.status}">${doc.status}</span>
                <span>${doc.chunks} chunks</span>
                <span>${formatSize(doc.length)}</span>
              </div>
              <div class="doc-preview">${escapeHtml(doc.preview)}</div>
            </div>
          `).join('');
        }
      } catch (e) {
        document.getElementById('docsLoading').style.display = 'none';
        document.getElementById('docsList').innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--danger);">
            Error loading documents
          </div>
        `;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function showDeleteModal(name) {
      pendingDeleteBucket = name;
      document.getElementById('deleteBucketName').textContent = name;
      openModal('deleteModal');
    }

    async function confirmDelete() {
      if (!pendingDeleteBucket) return;

      try {
        const response = await fetch(`${API_BASE}/api/buckets/${pendingDeleteBucket}`, {
          method: 'DELETE'
        });

        if (response.ok) {
          closeModal('deleteModal');
          loadBuckets();
        }
      } catch (e) {
        // Mock for frontend testing
        buckets = buckets.filter(b => b.name !== pendingDeleteBucket);
        closeModal('deleteModal');
        renderBuckets();
        updateImportSection();
      }

      pendingDeleteBucket = null;
    }

    function selectBucketForImport(name) {
      document.getElementById('targetBucket').value = name;
      document.getElementById('importSection').scrollIntoView({ behavior: 'smooth' });
    }

    function viewGraph(bucketName) {
      window.location.href = `/graph.html?bucket=${bucketName}`;
    }

    function queryBucket(bucketName) {
      const query = prompt('Enter your query:');
      if (!query) return;

      openModal('queryModal');
      document.getElementById('queryBucketName').textContent = bucketName;
      document.getElementById('queryContent').innerHTML = '<div style="text-align:center;padding:2rem;color:var(--text-muted)">Querying...</div>';

      fetch(`${API_BASE}/api/buckets/${bucketName}/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query, mode: 'hybrid' })
      })
        .then(r => r.json())
        .then(data => {
          document.getElementById('queryContent').innerHTML = `
            <div style="white-space:pre-wrap;font-size:0.8125rem;line-height:1.6">${escapeHtml(data.result || 'No results')}</div>
          `;
        })
        .catch(e => {
          document.getElementById('queryContent').innerHTML = `<div style="color:var(--danger)">Error: ${e.message}</div>`;
        });
    }

    async function resetStuckDocs(bucketName) {
      if (!confirm('Reset stuck processing/pending docs to allow re-upload?')) return;

      try {
        const response = await fetch(`${API_BASE}/api/buckets/${bucketName}/reset-stuck`, {
          method: 'POST'
        });
        if (response.ok) {
          const result = await response.json();
          alert(`Reset ${result.reset_count} stuck documents`);
          showDocuments(bucketName);
        }
      } catch (e) {
        alert('Error resetting stuck docs');
      }
    }

    // Upload Queue System
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const queueSection = document.getElementById('queueSection');
    const queueList = document.getElementById('queueList');
    const queueCount = document.getElementById('queueCount');

    const ALLOWED_TYPES = ['.txt', '.md', '.pdf', '.html'];
    const MAX_SIZE = 10 * 1024 * 1024; // 10MB warning threshold

    // Queue state: { id, file, name, size, status, error, progress, docId }
    let uploadQueue = [];
    let isProcessing = false;
    let statusPollInterval = null;

    dropZone.onclick = () => fileInput.click();

    dropZone.ondragover = (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    };

    dropZone.ondragleave = () => {
      dropZone.classList.remove('dragover');
    };

    dropZone.ondrop = (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    };

    fileInput.onchange = () => {
      handleFiles(fileInput.files);
      fileInput.value = ''; // Reset for re-upload of same file
    };

    function validateFile(file) {
      const ext = '.' + file.name.split('.').pop().toLowerCase();
      const errors = [];

      if (!ALLOWED_TYPES.includes(ext)) {
        errors.push(`Invalid type: ${ext}. Allowed: ${ALLOWED_TYPES.join(', ')}`);
      }

      if (file.size > MAX_SIZE) {
        errors.push(`Large file: ${formatSize(file.size)} (may take a while)`);
      }

      if (file.size === 0) {
        errors.push('Empty file');
      }

      return errors;
    }

    function handleFiles(files) {
      const bucket = document.getElementById('targetBucket').value;
      if (!bucket) {
        alert('Please select a target bucket first');
        return;
      }

      Array.from(files).forEach(file => {
        const errors = validateFile(file);
        const hasBlockingError = errors.some(e => e.startsWith('Invalid') || e.startsWith('Empty'));

        uploadQueue.push({
          id: crypto.randomUUID(),
          file,
          bucket,
          name: file.name,
          size: file.size,
          status: hasBlockingError ? 'error' : 'queued',
          error: errors.length > 0 ? errors.join('; ') : null,
          progress: 0,
          docId: null
        });
      });

      renderQueue();
      showQueueSection();

      if (!isProcessing) {
        processQueue();
      }
    }

    function showQueueSection() {
      queueSection.style.display = 'block';
    }

    function renderQueue() {
      const completed = uploadQueue.filter(q => q.status === 'done').length;
      queueCount.textContent = `${completed}/${uploadQueue.length}`;

      queueList.innerHTML = uploadQueue.map(item => {
        let icon, iconClass;
        switch (item.status) {
          case 'done':
            icon = '✓';
            iconClass = 'done';
            break;
          case 'processing':
          case 'extracting':
          case 'embedding':
            icon = `<div class="spinner"></div>`;
            iconClass = 'processing';
            break;
          case 'uploading':
            icon = '↑';
            iconClass = 'processing';
            break;
          case 'error':
            icon = '✕';
            iconClass = 'error';
            break;
          default:
            icon = '○';
            iconClass = 'queued';
        }

        const statusText = {
          'queued': 'Waiting...',
          'uploading': 'Uploading...',
          'processing': 'Chunking...',
          'extracting': 'Extracting entities...',
          'embedding': 'Building vectors...',
          'done': 'Complete',
          'error': item.error || 'Failed'
        }[item.status] || item.status;

        return `
          <div class="queue-item ${item.status === 'error' ? 'validation-error' : ''}">
            <div class="queue-icon ${iconClass}">${icon}</div>
            <div class="queue-info">
              <div class="queue-name">${escapeHtml(item.name)}</div>
              <div class="queue-meta">
                <span>${formatSize(item.size)}</span>
                <span>${statusText}</span>
              </div>
            </div>
            ${item.status === 'processing' || item.status === 'extracting' || item.status === 'embedding' ? `
              <div class="queue-progress">
                <div class="queue-progress-bar">
                  <div class="queue-progress-fill" style="width: ${item.progress}%"></div>
                </div>
                <div class="queue-progress-text">${item.progress}%</div>
              </div>
            ` : ''}
            ${item.status === 'queued' ? `
              <button class="btn btn-icon queue-action" onclick="removeFromQueue('${item.id}')">&times;</button>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    function removeFromQueue(id) {
      uploadQueue = uploadQueue.filter(q => q.id !== id);
      renderQueue();
      if (uploadQueue.length === 0) {
        queueSection.style.display = 'none';
      }
    }

    async function processQueue() {
      isProcessing = true;

      while (true) {
        const next = uploadQueue.find(q => q.status === 'queued');
        if (!next) break;

        next.status = 'uploading';
        renderQueue();

        try {
          const formData = new FormData();
          formData.append('file', next.file);

          const response = await fetch(`${API_BASE}/api/buckets/${next.bucket}/documents`, {
            method: 'POST',
            body: formData
          });

          if (response.ok) {
            const result = await response.json();
            next.docId = result.doc_id;
            next.status = 'processing';
            next.progress = 10;
            renderQueue();
          } else {
            const err = await response.json();
            next.status = 'error';
            next.error = err.detail || 'Upload failed';
            renderQueue();
          }
        } catch (e) {
          next.status = 'error';
          next.error = 'Connection failed';
          renderQueue();
        }
      }

      isProcessing = false;

      // Start polling for processing status
      startStatusPolling();
      loadBuckets();
    }

    function startStatusPolling() {
      if (statusPollInterval) return;

      statusPollInterval = setInterval(async () => {
        const processing = uploadQueue.filter(q =>
          ['queued', 'processing', 'extracting', 'embedding'].includes(q.status)
        );

        if (processing.length === 0) {
          clearInterval(statusPollInterval);
          statusPollInterval = null;
          loadBuckets();
          return;
        }

        // Poll each bucket for document status
        const bucketNames = [...new Set(processing.map(p => p.bucket))];

        for (const bucketName of bucketNames) {
          try {
            const response = await fetch(`${API_BASE}/api/buckets/${bucketName}/documents`);
            if (response.ok) {
              const docs = await response.json();

              // Update queue items from backend docs
              docs.forEach(doc => {
                // Find matching queue item
                const item = processing.find(p =>
                  p.bucket === bucketName && (
                    p.docId === doc.id ||
                    p.name === doc.title ||
                    p.name.toLowerCase() === doc.title.toLowerCase()
                  )
                );

                if (item) {
                  if (doc.status === 'processed') {
                    item.status = 'done';
                    item.progress = 100;
                  } else if (doc.status === 'processing') {
                    // Use actual chunk count for progress
                    const chunkProgress = doc.chunks > 0 ? Math.min(90, 20 + (doc.chunks * 2)) : 30;
                    item.progress = Math.max(item.progress, chunkProgress);

                    // Cycle through stages based on progress
                    if (item.progress < 40) item.status = 'processing';
                    else if (item.progress < 70) item.status = 'extracting';
                    else item.status = 'embedding';
                  } else if (doc.status === 'pending') {
                    item.status = 'queued';
                    item.progress = 0;
                  }
                }
              });
            }
          } catch (e) {
            console.log('Status poll error:', e);
          }
        }

        renderQueue();
      }, 2000);
    }

    function clearQueue() {
      uploadQueue = uploadQueue.filter(q => q.status !== 'done' && q.status !== 'error');
      renderQueue();
      if (uploadQueue.length === 0) {
        queueSection.style.display = 'none';
      }
    }

    // Folder import
    document.getElementById('importFolderBtn').onclick = async () => {
      const bucket = document.getElementById('targetBucket').value;
      const folderPath = document.getElementById('folderPath').value.trim();

      if (!bucket) {
        alert('Please select a target bucket');
        return;
      }

      if (!folderPath) {
        alert('Please enter a folder path');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/buckets/${bucket}/import-folder`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: folderPath })
        });

        if (response.ok) {
          alert('Folder import started');
          loadBuckets();
        }
      } catch (e) {
        alert('Folder import would be triggered for: ' + folderPath);
      }
    };

    // Load currently processing/pending documents from backend
    async function loadProcessingDocs() {
      try {
        const bucketsRes = await fetch(`${API_BASE}/api/buckets`);
        if (!bucketsRes.ok) return;

        const bucketList = await bucketsRes.json();

        for (const bucket of bucketList) {
          const docsRes = await fetch(`${API_BASE}/api/buckets/${bucket.name}/documents`);
          if (!docsRes.ok) continue;

          const docs = await docsRes.json();
          const active = docs.filter(d => d.status === 'processing' || d.status === 'pending');

          active.forEach(doc => {
            // Don't add duplicates
            if (uploadQueue.some(q => q.name === doc.title)) return;

            let status, progress;
            if (doc.status === 'pending') {
              status = 'queued';
              progress = 0;
            } else {
              // Processing - estimate progress from chunks
              const chunkProgress = doc.chunks > 0 ? Math.min(90, 20 + (doc.chunks * 2)) : 30;
              status = chunkProgress < 40 ? 'processing' : chunkProgress < 70 ? 'extracting' : 'embedding';
              progress = chunkProgress;
            }

            uploadQueue.push({
              id: crypto.randomUUID(),
              file: null,
              bucket: bucket.name,
              name: doc.title || doc.id,
              size: doc.length || 0,
              status,
              error: null,
              progress,
              docId: doc.id
            });
          });
        }

        if (uploadQueue.length > 0) {
          renderQueue();
          showQueueSection();
          startStatusPolling();
        }
      } catch (e) {
        console.log('Could not load processing docs:', e);
      }
    }

    // Initial load
    loadBuckets();
    loadProcessingDocs();
  </script>
</body>
</html>
